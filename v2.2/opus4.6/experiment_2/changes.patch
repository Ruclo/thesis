diff --git a/tests/virt/cluster/vnc_screenshot/__init__.py b/tests/virt/cluster/vnc_screenshot/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/tests/virt/cluster/vnc_screenshot/conftest.py b/tests/virt/cluster/vnc_screenshot/conftest.py
new file mode 100644
index 0000000..1e4653e
--- /dev/null
+++ b/tests/virt/cluster/vnc_screenshot/conftest.py
@@ -0,0 +1,18 @@
+import pytest
+from ocp_resources.virtual_machine import VirtualMachine
+
+from utilities.virt import VirtualMachineForTests, fedora_vm_body, running_vm
+
+
+@pytest.fixture(scope="class")
+def vnc_screenshot_vm(namespace, unprivileged_client):
+    vm_name = "fedora-vnc-screenshot"
+    with VirtualMachineForTests(
+        name=vm_name,
+        namespace=namespace.name,
+        client=unprivileged_client,
+        body=fedora_vm_body(name=vm_name),
+        run_strategy=VirtualMachine.RunStrategy.ALWAYS,
+    ) as vm:
+        running_vm(vm=vm)
+        yield vm
diff --git a/tests/virt/cluster/vnc_screenshot/test_vnc_screenshot.py b/tests/virt/cluster/vnc_screenshot/test_vnc_screenshot.py
new file mode 100644
index 0000000..9f56cad
--- /dev/null
+++ b/tests/virt/cluster/vnc_screenshot/test_vnc_screenshot.py
@@ -0,0 +1,224 @@
+"""
+VNC Screenshot via libvirt virDomainScreenshot Tests
+
+STP Reference: /home/jzo/thesis/stps/2.md
+Jira: CNV-61271 (Feature), CNV-60117 (Bug Fix)
+PR: https://github.com/kubevirt/kubevirt/pull/15238
+
+This module contains tests verifying that the vnc/screenshot subresource uses
+libvirt's virDomainScreenshot API instead of VNC, ensuring screenshots do not
+compete with active VNC connections.
+"""
+
+import logging
+import os
+import shlex
+import tempfile
+
+import pytest
+
+from utilities.infra import run_virtctl_command
+from utilities.vnc_utils import VNCConnection
+
+LOGGER = logging.getLogger(__name__)
+
+PNG_HEADER = b"\x89PNG\r\n\x1a\n"
+
+
+def take_screenshot(vm_name: str, vm_namespace: str, output_path: str) -> str:
+    """Take a VNC screenshot of a VM using virtctl and return the output file path.
+
+    Args:
+        vm_name: Name of the virtual machine.
+        vm_namespace: Namespace of the virtual machine.
+        output_path: File path to save the screenshot.
+
+    Returns:
+        The output file path.
+    """
+    run_virtctl_command(
+        command=shlex.split(f"vnc screenshot {vm_name} -f {output_path}"),
+        namespace=vm_namespace,
+        check=True,
+    )
+    return output_path
+
+
+@pytest.mark.virt
+class TestVncScreenshotIndependence:
+    """
+    Tests that the vnc/screenshot subresource works independently of VNC connections.
+
+    Preconditions:
+        - Running VM with a graphical console device configured
+        - VM is SSH accessible
+    """
+
+    @pytest.mark.polarion("CNV-61271")
+    def test_screenshot_without_vnc_connection(self, vnc_screenshot_vm):
+        """
+        Test that a screenshot can be taken without any active VNC connection.
+
+        Steps:
+            1. Call virtctl vnc screenshot for the VM
+
+        Expected:
+            - Screenshot file is created and is a valid image with non-zero size
+        """
+        with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as screenshot_file:
+            screenshot_path = screenshot_file.name
+
+        try:
+            LOGGER.info(f"Taking screenshot of VM {vnc_screenshot_vm.name} without active VNC connection")
+            take_screenshot(
+                vm_name=vnc_screenshot_vm.name,
+                vm_namespace=vnc_screenshot_vm.namespace,
+                output_path=screenshot_path,
+            )
+            file_size = os.path.getsize(screenshot_path)
+            LOGGER.info(f"Screenshot saved to {screenshot_path}, size: {file_size} bytes")
+            assert file_size > 0, f"Screenshot file is empty: {screenshot_path}"
+        finally:
+            os.unlink(screenshot_path)
+
+    @pytest.mark.polarion("CNV-61271")
+    def test_screenshot_returns_valid_image(self, vnc_screenshot_vm):
+        """
+        Test that the screenshot produces a recognizable image of the VM display.
+
+        Steps:
+            1. Call virtctl vnc screenshot for the VM
+            2. Read the resulting screenshot file
+
+        Expected:
+            - Screenshot file has a valid PNG header
+        """
+        with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as screenshot_file:
+            screenshot_path = screenshot_file.name
+
+        try:
+            LOGGER.info(f"Taking screenshot of VM {vnc_screenshot_vm.name} to verify PNG format")
+            take_screenshot(
+                vm_name=vnc_screenshot_vm.name,
+                vm_namespace=vnc_screenshot_vm.namespace,
+                output_path=screenshot_path,
+            )
+            with open(screenshot_path, "rb") as image_file:
+                header = image_file.read(len(PNG_HEADER))
+            LOGGER.info(f"Screenshot header bytes: {header!r}")
+            assert header == PNG_HEADER, f"Screenshot does not have a valid PNG header, got: {header!r}"
+        finally:
+            os.unlink(screenshot_path)
+
+
+@pytest.mark.virt
+class TestVncStabilityWithScreenshot:
+    """
+    Tests that VNC connections remain stable when screenshots are taken concurrently.
+
+    Preconditions:
+        - Running VM with a graphical console device configured
+        - VM is SSH accessible
+    """
+
+    @pytest.mark.polarion("CNV-61271")
+    def test_vnc_connection_survives_concurrent_screenshot(self, vnc_screenshot_vm):
+        """
+        Test that an active VNC connection is not disconnected when a screenshot is taken.
+
+        Steps:
+            1. Establish a VNC proxy connection to the VM
+            2. While VNC is connected, call virtctl vnc screenshot for the VM
+            3. Verify the VNC proxy connection is still alive
+
+        Expected:
+            - VNC proxy connection remains open after screenshot is taken
+        """
+        with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as screenshot_file:
+            screenshot_path = screenshot_file.name
+
+        try:
+            with VNCConnection(vm=vnc_screenshot_vm) as vnc_child:
+                assert vnc_child, "Failed to establish VNC proxy connection"
+                LOGGER.info(f"VNC connection established for VM {vnc_screenshot_vm.name}")
+                LOGGER.info("Taking screenshot while VNC connection is active")
+                take_screenshot(
+                    vm_name=vnc_screenshot_vm.name,
+                    vm_namespace=vnc_screenshot_vm.namespace,
+                    output_path=screenshot_path,
+                )
+                assert vnc_child.isalive(), "VNC proxy connection was terminated after screenshot was taken"
+                LOGGER.info("VNC connection remains alive after screenshot")
+        finally:
+            if os.path.exists(screenshot_path):
+                os.unlink(screenshot_path)
+
+    @pytest.mark.polarion("CNV-61271")
+    def test_vnc_connection_survives_repeated_screenshots(self, vnc_screenshot_vm):
+        """
+        Test that an active VNC connection remains stable through multiple consecutive screenshots.
+
+        Steps:
+            1. Establish a VNC proxy connection to the VM
+            2. Take 5 consecutive screenshots while VNC is connected
+            3. Verify the VNC proxy connection is still alive after all screenshots
+
+        Expected:
+            - VNC proxy connection remains open after all screenshots complete
+        """
+        screenshot_count = 5
+        screenshot_paths: list[str] = []
+
+        try:
+            with VNCConnection(vm=vnc_screenshot_vm) as vnc_child:
+                assert vnc_child, "Failed to establish VNC proxy connection"
+                LOGGER.info(f"VNC connection established for VM {vnc_screenshot_vm.name}")
+                for iteration in range(screenshot_count):
+                    with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as screenshot_file:
+                        screenshot_path = screenshot_file.name
+                    screenshot_paths.append(screenshot_path)
+                    LOGGER.info(f"Taking screenshot {iteration + 1}/{screenshot_count}")
+                    take_screenshot(
+                        vm_name=vnc_screenshot_vm.name,
+                        vm_namespace=vnc_screenshot_vm.namespace,
+                        output_path=screenshot_path,
+                    )
+                assert vnc_child.isalive(), (
+                    f"VNC proxy connection was terminated after {screenshot_count} consecutive screenshots"
+                )
+                LOGGER.info(f"VNC connection remains alive after {screenshot_count} consecutive screenshots")
+        finally:
+            for path in screenshot_paths:
+                if os.path.exists(path):
+                    os.unlink(path)
+
+    @pytest.mark.polarion("CNV-61271")
+    def test_screenshot_succeeds_with_active_vnc(self, vnc_screenshot_vm):
+        """
+        Test that a screenshot is successfully captured while a VNC connection is active.
+
+        Steps:
+            1. Establish a VNC proxy connection to the VM
+            2. Call virtctl vnc screenshot for the VM
+
+        Expected:
+            - Screenshot file is created and is a valid image with non-zero size
+        """
+        with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as screenshot_file:
+            screenshot_path = screenshot_file.name
+
+        try:
+            with VNCConnection(vm=vnc_screenshot_vm):
+                LOGGER.info(f"VNC connection established for VM {vnc_screenshot_vm.name}")
+                LOGGER.info("Taking screenshot while VNC connection is active")
+                take_screenshot(
+                    vm_name=vnc_screenshot_vm.name,
+                    vm_namespace=vnc_screenshot_vm.namespace,
+                    output_path=screenshot_path,
+                )
+                file_size = os.path.getsize(screenshot_path)
+                LOGGER.info(f"Screenshot saved to {screenshot_path}, size: {file_size} bytes")
+                assert file_size > 0, f"Screenshot file is empty while VNC was active: {screenshot_path}"
+        finally:
+            if os.path.exists(screenshot_path):
+                os.unlink(screenshot_path)
