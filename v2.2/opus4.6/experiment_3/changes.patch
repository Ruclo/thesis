diff --git a/tests/virt/node/general/test_vmi_hard_reset.py b/tests/virt/node/general/test_vmi_hard_reset.py
new file mode 100644
index 0000000..6b6c3ee
--- /dev/null
+++ b/tests/virt/node/general/test_vmi_hard_reset.py
@@ -0,0 +1,429 @@
+"""
+VMI Force/Hard Reset Tests
+
+STP Reference: https://issues.redhat.com/browse/VIRTSTRAT-357
+
+This module contains tests for the VMI hard reset feature, which allows
+resetting a hung or unresponsive VirtualMachineInstance without pod
+rescheduling. The reset simulates pressing the hardware reset button
+on a physical machine.
+"""
+
+import logging
+import shlex
+from collections.abc import Generator
+
+import pytest
+from kubernetes.dynamic import DynamicClient
+from kubernetes.dynamic.exceptions import ForbiddenError, NotFoundError
+from ocp_resources.cluster_role import ClusterRole
+from ocp_resources.namespace import Namespace
+from ocp_resources.role_binding import RoleBinding
+from ocp_resources.virtual_machine_instance import VirtualMachineInstance
+from pyhelper_utils.shell import run_ssh_commands
+
+from utilities.constants import UNPRIVILEGED_USER
+from utilities.infra import run_virtctl_command
+from utilities.virt import VirtualMachineForTests, fedora_vm_body, running_vm, wait_for_running_vm
+
+LOGGER = logging.getLogger(__name__)
+
+pytestmark = pytest.mark.tier2
+
+
+def get_vm_boot_count(vm: VirtualMachineForTests) -> int:
+    """Get the number of boot entries from the VM's journal.
+
+    Args:
+        vm: The virtual machine to query.
+
+    Returns:
+        The number of boot entries recorded by systemd journal.
+    """
+    reboot_count = run_ssh_commands(
+        host=vm.ssh_exec,
+        commands=[shlex.split("journalctl --list-boots | wc -l")],
+    )[0].strip()
+    return int(reboot_count)
+
+
+@pytest.fixture(scope="class")
+def boot_count_before_api_reset(vm_for_hard_reset_api: VirtualMachineForTests) -> int:
+    return get_vm_boot_count(vm=vm_for_hard_reset_api)
+
+
+@pytest.fixture(scope="class")
+def vmi_uid_before_api_reset(vm_for_hard_reset_api: VirtualMachineForTests) -> str:
+    return vm_for_hard_reset_api.vmi.instance.metadata.uid
+
+
+@pytest.fixture(scope="class")
+def pod_name_before_api_reset(vm_for_hard_reset_api: VirtualMachineForTests) -> str:
+    virt_launcher_pod = vm_for_hard_reset_api.vmi.virt_launcher_pod
+    assert virt_launcher_pod, "Virt-launcher pod not found for running VMI"
+    return virt_launcher_pod.name
+
+
+@pytest.fixture(scope="class")
+def vm_api_reset_and_running(vm_for_hard_reset_api: VirtualMachineForTests) -> None:
+    LOGGER.info(f"Resetting VMI {vm_for_hard_reset_api.name} via subresource API")
+    vm_for_hard_reset_api.vmi.reset()
+    wait_for_running_vm(vm=vm_for_hard_reset_api)
+
+
+@pytest.fixture(scope="class")
+def vm_for_hard_reset_api(
+    unprivileged_client: DynamicClient,
+    namespace: Namespace,
+) -> Generator[VirtualMachineForTests]:
+    vm_name = "vm-hard-reset-api"
+    with VirtualMachineForTests(
+        name=vm_name,
+        client=unprivileged_client,
+        namespace=namespace.name,
+        body=fedora_vm_body(name=vm_name),
+    ) as vm:
+        running_vm(vm=vm)
+        yield vm
+
+
+@pytest.fixture(scope="class")
+def vm_for_hard_reset_virtctl(
+    unprivileged_client: DynamicClient,
+    namespace: Namespace,
+) -> Generator[VirtualMachineForTests]:
+    vm_name = "vm-hard-reset-virtctl"
+    with VirtualMachineForTests(
+        name=vm_name,
+        client=unprivileged_client,
+        namespace=namespace.name,
+        body=fedora_vm_body(name=vm_name),
+    ) as vm:
+        running_vm(vm=vm)
+        yield vm
+
+
+@pytest.fixture(scope="class")
+def boot_count_before_virtctl_reset(vm_for_hard_reset_virtctl: VirtualMachineForTests) -> int:
+    return get_vm_boot_count(vm=vm_for_hard_reset_virtctl)
+
+
+@pytest.fixture(scope="class")
+def vm_virtctl_reset_and_running(vm_for_hard_reset_virtctl: VirtualMachineForTests) -> None:
+    LOGGER.info(f"Resetting VMI {vm_for_hard_reset_virtctl.name} via virtctl")
+    run_virtctl_command(
+        command=shlex.split(f"reset {vm_for_hard_reset_virtctl.name}"),
+        namespace=vm_for_hard_reset_virtctl.namespace,
+        check=True,
+    )
+    wait_for_running_vm(vm=vm_for_hard_reset_virtctl)
+
+
+@pytest.fixture(scope="class")
+def vm_for_rbac_reset(
+    unprivileged_client: DynamicClient,
+    namespace: Namespace,
+) -> Generator[VirtualMachineForTests]:
+    vm_name = "vm-rbac-reset"
+    with VirtualMachineForTests(
+        name=vm_name,
+        client=unprivileged_client,
+        namespace=namespace.name,
+        body=fedora_vm_body(name=vm_name),
+    ) as vm:
+        running_vm(vm=vm)
+        yield vm
+
+
+@pytest.fixture(scope="class")
+def unprivileged_vmi_for_reset(
+    admin_client: DynamicClient,
+    vm_for_rbac_reset: VirtualMachineForTests,
+) -> VirtualMachineInstance:
+    """VMI object using admin_client without edit role permissions.
+
+    The unprivileged_client already has namespace-admin permissions which
+    include the edit role. To test a truly unprivileged reset, we create
+    a VMI reference using admin_client and then swap to a restricted context.
+    However, since the vm_for_rbac_reset was created by unprivileged_client
+    (which is namespace admin), we need a separate unprivileged VMI handle.
+    The unprivileged_client by default does NOT have the
+    virtualmachineinstances/reset subresource permission unless the edit
+    ClusterRole grants it.
+    """
+    return VirtualMachineInstance(
+        name=vm_for_rbac_reset.vmi.name,
+        namespace=vm_for_rbac_reset.namespace,
+        client=admin_client,
+    )
+
+
+@pytest.fixture(scope="class")
+def kubevirt_edit_cluster_role(admin_client: DynamicClient) -> ClusterRole:
+    return ClusterRole(name="kubevirt.io:edit", client=admin_client, ensure_exists=True)
+
+
+@pytest.fixture(scope="class")
+def unprivileged_user_edit_rolebinding(
+    admin_client: DynamicClient,
+    namespace: Namespace,
+    kubevirt_edit_cluster_role: ClusterRole,
+) -> Generator[RoleBinding]:
+    with RoleBinding(
+        name="role-bind-kubevirt-edit-reset",
+        namespace=namespace.name,
+        client=admin_client,
+        subjects_kind="User",
+        subjects_name=UNPRIVILEGED_USER,
+        subjects_namespace=namespace.name,
+        role_ref_kind=kubevirt_edit_cluster_role.kind,
+        role_ref_name=kubevirt_edit_cluster_role.name,
+    ) as role_binding:
+        yield role_binding
+
+
+@pytest.fixture(scope="class")
+def vm_for_negative_reset(
+    unprivileged_client: DynamicClient,
+    namespace: Namespace,
+) -> Generator[VirtualMachineForTests]:
+    vm_name = "vm-negative-reset"
+    with VirtualMachineForTests(
+        name=vm_name,
+        client=unprivileged_client,
+        namespace=namespace.name,
+        body=fedora_vm_body(name=vm_name),
+    ) as vm:
+        running_vm(vm=vm)
+        yield vm
+
+
+@pytest.fixture()
+def stopped_vm_for_reset(
+    vm_for_negative_reset: VirtualMachineForTests,
+) -> Generator[VirtualMachineForTests]:
+    LOGGER.info(f"Stopping VM {vm_for_negative_reset.name}")
+    vm_for_negative_reset.stop(wait=True)
+    yield vm_for_negative_reset
+    LOGGER.info(f"Restarting VM {vm_for_negative_reset.name}")
+    vm_for_negative_reset.start()
+    wait_for_running_vm(vm=vm_for_negative_reset)
+
+
+@pytest.fixture()
+def paused_vm_for_reset(
+    vm_for_negative_reset: VirtualMachineForTests,
+) -> Generator[VirtualMachineForTests]:
+    LOGGER.info(f"Pausing VMI {vm_for_negative_reset.name}")
+    vm_for_negative_reset.vmi.pause(wait=True)
+    yield vm_for_negative_reset
+    LOGGER.info(f"Unpausing VMI {vm_for_negative_reset.name}")
+    vm_for_negative_reset.vmi.unpause(wait=True)
+
+
+class TestVMIHardResetAPI:
+    """Tests for VMI hard reset via the subresource API.
+
+    Verifies that resetting a running VMI via the subresource API triggers
+    an actual guest reboot while preserving the pod assignment and VMI UID.
+    """
+
+    @pytest.mark.polarion("CNV-12374")
+    def test_vmi_reset_triggers_guest_reboot(
+        self,
+        vm_for_hard_reset_api: VirtualMachineForTests,
+        boot_count_before_api_reset: int,
+        vm_api_reset_and_running: None,
+    ) -> None:
+        """Test that resetting a running VMI via the API triggers a guest reboot.
+
+        Steps:
+            1. Reset the VMI via the subresource API
+            2. Wait for the VM to become running and SSH accessible
+            3. Read the guest boot count
+
+        Expected:
+            - Guest boot count after reset is exactly one more than before reset
+        """
+        boot_count_after = get_vm_boot_count(vm=vm_for_hard_reset_api)
+        assert boot_count_after - boot_count_before_api_reset == 1, (
+            f"Expected exactly 1 new boot entry after VMI reset, "
+            f"got {boot_count_after - boot_count_before_api_reset}"
+        )
+
+    @pytest.mark.polarion("CNV-12375")
+    def test_vmi_reset_preserves_pod(
+        self,
+        vm_for_hard_reset_api: VirtualMachineForTests,
+        pod_name_before_api_reset: str,
+        vm_api_reset_and_running: None,
+    ) -> None:
+        """Test that resetting a VMI does not cause pod rescheduling.
+
+        Steps:
+            1. Read the pod name hosting the VMI after reset
+
+        Expected:
+            - Pod name after reset equals pod name before reset
+        """
+        virt_launcher_pod = vm_for_hard_reset_api.vmi.virt_launcher_pod
+        assert virt_launcher_pod, "Virt-launcher pod not found after VMI reset"
+        assert virt_launcher_pod.name == pod_name_before_api_reset, (
+            f"Pod was rescheduled after reset: before={pod_name_before_api_reset}, after={virt_launcher_pod.name}"
+        )
+
+    @pytest.mark.polarion("CNV-12376")
+    def test_vmi_reset_preserves_uid(
+        self,
+        vm_for_hard_reset_api: VirtualMachineForTests,
+        vmi_uid_before_api_reset: str,
+        vm_api_reset_and_running: None,
+    ) -> None:
+        """Test that the VMI UID remains unchanged after a reset.
+
+        Steps:
+            1. Read the VMI UID after reset
+
+        Expected:
+            - VMI UID after reset equals VMI UID before reset
+        """
+        vmi_uid_after = vm_for_hard_reset_api.vmi.instance.metadata.uid
+        assert vmi_uid_after == vmi_uid_before_api_reset, (
+            f"VMI UID changed after reset: before={vmi_uid_before_api_reset}, after={vmi_uid_after}"
+        )
+
+
+class TestVMIHardResetVirtctl:
+    """Tests for VMI hard reset via the virtctl CLI.
+
+    Verifies that the `virtctl reset` command triggers a guest reboot
+    on a running VMI.
+    """
+
+    @pytest.mark.polarion("CNV-12377")
+    def test_virtctl_reset_triggers_guest_reboot(
+        self,
+        vm_for_hard_reset_virtctl: VirtualMachineForTests,
+        boot_count_before_virtctl_reset: int,
+        vm_virtctl_reset_and_running: None,
+    ) -> None:
+        """Test that resetting a running VMI via virtctl triggers a guest reboot.
+
+        Steps:
+            1. Execute `virtctl reset <vm-name>` command
+            2. Wait for the VM to become running and SSH accessible
+            3. Read the guest boot count
+
+        Expected:
+            - Guest boot count after reset is exactly one more than before reset
+        """
+        boot_count_after = get_vm_boot_count(vm=vm_for_hard_reset_virtctl)
+        assert boot_count_after - boot_count_before_virtctl_reset == 1, (
+            f"Expected exactly 1 new boot entry after virtctl reset, "
+            f"got {boot_count_after - boot_count_before_virtctl_reset}"
+        )
+
+
+class TestVMIHardResetRBAC:
+    """Tests for RBAC enforcement on the VMI reset operation.
+
+    Verifies that the reset subresource permission is properly enforced:
+    unprivileged users without the edit role cannot reset a VMI, while
+    users with the edit ClusterRole can.
+    """
+
+    @pytest.mark.polarion("CNV-12378")
+    def test_unprivileged_user_cannot_reset_vmi(
+        self,
+        unprivileged_vmi_for_reset: VirtualMachineInstance,
+    ) -> None:
+        """[NEGATIVE] Test that an unprivileged user cannot reset a VMI.
+
+        Steps:
+            1. Attempt to reset the VMI using an unprivileged client
+
+        Expected:
+            - Reset operation fails with a 403 Forbidden error
+        """
+        with pytest.raises(ForbiddenError):
+            unprivileged_vmi_for_reset.reset()
+
+    @pytest.mark.polarion("CNV-12379")
+    @pytest.mark.usefixtures("unprivileged_user_edit_rolebinding")
+    def test_user_with_edit_role_can_reset_vmi(
+        self,
+        vm_for_rbac_reset: VirtualMachineForTests,
+    ) -> None:
+        """Test that a user with the edit ClusterRole can reset a VMI.
+
+        Steps:
+            1. Reset the VMI using a client with edit role
+            2. Wait for the VM to become running
+
+        Expected:
+            - Reset operation succeeds without error
+        """
+        vm_for_rbac_reset.vmi.reset()
+        wait_for_running_vm(vm=vm_for_rbac_reset)
+
+
+class TestVMIHardResetNegative:
+    """Tests for VMI reset error handling on non-running VMIs.
+
+    Verifies that the reset operation returns appropriate errors when
+    the VMI is not in a running state or does not exist.
+    """
+
+    @pytest.mark.polarion("CNV-12380")
+    def test_reset_stopped_vmi_fails(
+        self,
+        stopped_vm_for_reset: VirtualMachineForTests,
+    ) -> None:
+        """[NEGATIVE] Test that resetting a stopped VMI returns an appropriate error.
+
+        Steps:
+            1. Attempt to reset the stopped VMI via the API
+
+        Expected:
+            - Reset operation fails with an error indicating the VMI is not running
+        """
+        with pytest.raises(NotFoundError):
+            stopped_vm_for_reset.vmi.reset()
+
+    @pytest.mark.polarion("CNV-12381")
+    def test_reset_paused_vmi_fails(
+        self,
+        paused_vm_for_reset: VirtualMachineForTests,
+    ) -> None:
+        """[NEGATIVE] Test that resetting a paused VMI returns an appropriate error.
+
+        Steps:
+            1. Attempt to reset the paused VMI via the API
+
+        Expected:
+            - Reset operation fails with an error indicating the VMI is paused
+        """
+        with pytest.raises(Exception, match="paused|Paused"):
+            paused_vm_for_reset.vmi.reset()
+
+    @pytest.mark.polarion("CNV-12382")
+    def test_reset_nonexistent_vmi_fails(
+        self,
+        namespace: Namespace,
+        admin_client: DynamicClient,
+    ) -> None:
+        """[NEGATIVE] Test that resetting a non-existent VMI returns a 404 error.
+
+        Steps:
+            1. Attempt to reset a VMI with a name that does not exist in the namespace
+
+        Expected:
+            - Reset operation fails with a 404 Not Found error
+        """
+        nonexistent_vmi = VirtualMachineInstance(
+            name="nonexistent-vmi-for-reset",
+            namespace=namespace.name,
+            client=admin_client,
+        )
+        with pytest.raises(NotFoundError):
+            nonexistent_vmi.reset()
