diff --git a/tests/virt/node/vnc_screenshot/__init__.py b/tests/virt/node/vnc_screenshot/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/tests/virt/node/vnc_screenshot/conftest.py b/tests/virt/node/vnc_screenshot/conftest.py
new file mode 100644
index 0000000..2b2388a
--- /dev/null
+++ b/tests/virt/node/vnc_screenshot/conftest.py
@@ -0,0 +1,65 @@
+import logging
+import shlex
+import tempfile
+
+import pytest
+from ocp_resources.virtual_machine import VirtualMachine
+
+from utilities.constants import TIMEOUT_5MIN
+from utilities.infra import run_virtctl_command
+from utilities.virt import VirtualMachineForTests, fedora_vm_body, running_vm
+
+LOGGER = logging.getLogger(__name__)
+
+
+@pytest.fixture(scope="class")
+def vm_for_vnc_screenshot(namespace, unprivileged_client):
+    """Fedora VM with container disk for VNC screenshot testing."""
+    vm_name = "fedora-vnc-screenshot"
+    with VirtualMachineForTests(
+        name=vm_name,
+        namespace=namespace.name,
+        client=unprivileged_client,
+        body=fedora_vm_body(name=vm_name),
+        run_strategy=VirtualMachine.RunStrategy.ALWAYS,
+    ) as vm:
+        running_vm(vm=vm, wait_for_cloud_init=True)
+        yield vm
+
+
+@pytest.fixture()
+def screenshot_via_virtctl(vm_for_vnc_screenshot):
+    """Screenshot PNG file captured via virtctl vnc screenshot command.
+
+    Returns:
+        str: Path to the captured screenshot PNG file.
+    """
+    with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as screenshot_file:
+        screenshot_path = screenshot_file.name
+
+    LOGGER.info(
+        f"Capturing screenshot for VM {vm_for_vnc_screenshot.name} via virtctl to {screenshot_path}"
+    )
+    success, stdout, stderr = run_virtctl_command(
+        command=shlex.split(f"vnc screenshot {vm_for_vnc_screenshot.name} -f {screenshot_path}"),
+        namespace=vm_for_vnc_screenshot.namespace,
+        check=True,
+    )
+    return screenshot_path
+
+
+@pytest.fixture()
+def screenshot_via_api(vm_for_vnc_screenshot):
+    """Screenshot data retrieved via VMI subresource API.
+
+    Returns:
+        dict | bytes: Response from the vnc/screenshot subresource API.
+    """
+    LOGGER.info(
+        f"Capturing screenshot for VM {vm_for_vnc_screenshot.name} via subresource API"
+    )
+    return vm_for_vnc_screenshot.vmi.api_request(
+        method="GET",
+        action="vnc/screenshot",
+        retry_params={"timeout": TIMEOUT_5MIN, "sleep_time": 5},
+    )
diff --git a/tests/virt/node/vnc_screenshot/test_vnc_screenshot.py b/tests/virt/node/vnc_screenshot/test_vnc_screenshot.py
new file mode 100644
index 0000000..aabff85
--- /dev/null
+++ b/tests/virt/node/vnc_screenshot/test_vnc_screenshot.py
@@ -0,0 +1,145 @@
+"""
+Tests for VNC screenshot functionality via libvirt virDomainScreenshot API.
+
+Validates that the vnc/screenshot endpoint uses libvirt's virDomainScreenshot instead
+of VNC, ensuring VNC connections remain stable when screenshots are captured
+concurrently.
+
+Jira: CNV-61271 / CNV-60117
+PR: kubevirt/kubevirt#15238
+"""
+
+import logging
+import os
+
+import pytest
+from timeout_sampler import TimeoutSampler
+
+from utilities.constants import TIMEOUT_5MIN, TIMEOUT_30SEC
+from utilities.vnc_utils import VNCConnection
+
+LOGGER = logging.getLogger(__name__)
+
+SCREENSHOT_REPEAT_COUNT = 5
+
+
+@pytest.mark.virt
+class TestVncScreenshotApi:
+    """Tests for the vnc/screenshot subresource API endpoint."""
+
+    @pytest.mark.polarion("CNV-61271")
+    def test_screenshot_api_returns_data(
+        self,
+        vm_for_vnc_screenshot,
+        screenshot_via_api,
+    ):
+        """Scenario 2: Screenshot API returns data without requiring a VNC connection.
+
+        Verifies the vnc/screenshot endpoint returns non-empty screenshot data
+        using the libvirt virDomainScreenshot backend.
+        """
+        assert screenshot_via_api, (
+            f"Screenshot API returned empty response for VM {vm_for_vnc_screenshot.name}"
+        )
+
+    @pytest.mark.polarion("CNV-61271")
+    def test_screenshot_virtctl_creates_file(
+        self,
+        vm_for_vnc_screenshot,
+        screenshot_via_virtctl,
+    ):
+        """Scenario 3: Screenshot captured via virtctl produces a valid PNG file.
+
+        Verifies the virtctl vnc screenshot command creates a non-empty PNG file.
+        """
+        assert os.path.exists(screenshot_via_virtctl), (
+            f"Screenshot file not created at {screenshot_via_virtctl}"
+        )
+        file_size = os.path.getsize(screenshot_via_virtctl)
+        assert file_size > 0, (
+            f"Screenshot file is empty (0 bytes) at {screenshot_via_virtctl}"
+        )
+        LOGGER.info(
+            f"Screenshot file created successfully: {screenshot_via_virtctl} ({file_size} bytes)"
+        )
+
+
+@pytest.mark.virt
+class TestVncStabilityWithScreenshot:
+    """Tests verifying VNC connection stability when screenshots are taken concurrently."""
+
+    @pytest.mark.polarion("CNV-61271")
+    def test_vnc_stable_during_screenshot(self, vm_for_vnc_screenshot):
+        """Scenario 1: VNC connection remains stable when screenshot API is called.
+
+        Opens a VNC proxy connection, takes a screenshot via the subresource API,
+        then verifies the VNC connection is still alive.
+        """
+        with VNCConnection(vm=vm_for_vnc_screenshot) as vnc_child:
+            assert vnc_child, "Failed to establish VNC connection"
+            LOGGER.info("VNC connection established, calling screenshot API")
+            screenshot_response = vm_for_vnc_screenshot.vmi.api_request(
+                method="GET",
+                action="vnc/screenshot",
+            )
+            assert screenshot_response, "Screenshot API returned empty response during active VNC"
+            assert vnc_child.isalive(), (
+                "VNC connection dropped after screenshot API call"
+            )
+            LOGGER.info("VNC connection remains stable after screenshot API call")
+
+    @pytest.mark.polarion("CNV-61271")
+    def test_vnc_stable_during_repeated_screenshots(self, vm_for_vnc_screenshot):
+        """Scenario 4: VNC connection unaffected by multiple screenshot requests.
+
+        Opens a VNC proxy connection and takes multiple screenshots via the
+        subresource API, verifying VNC stays connected throughout.
+        """
+        with VNCConnection(vm=vm_for_vnc_screenshot) as vnc_child:
+            assert vnc_child, "Failed to establish VNC connection"
+            LOGGER.info(
+                f"VNC connection established, taking {SCREENSHOT_REPEAT_COUNT} screenshots"
+            )
+            for screenshot_index in range(SCREENSHOT_REPEAT_COUNT):
+                screenshot_response = vm_for_vnc_screenshot.vmi.api_request(
+                    method="GET",
+                    action="vnc/screenshot",
+                )
+                assert screenshot_response, (
+                    f"Screenshot API returned empty response on iteration {screenshot_index + 1}"
+                )
+                assert vnc_child.isalive(), (
+                    f"VNC connection dropped after screenshot iteration {screenshot_index + 1}"
+                )
+                LOGGER.info(
+                    f"Screenshot {screenshot_index + 1}/{SCREENSHOT_REPEAT_COUNT} captured, VNC still connected"
+                )
+            LOGGER.info(
+                f"VNC connection remained stable through all {SCREENSHOT_REPEAT_COUNT} screenshot requests"
+            )
+
+    @pytest.mark.tier3
+    @pytest.mark.polarion("CNV-61271")
+    def test_vnc_stable_during_extended_screenshot_polling(self, vm_for_vnc_screenshot):
+        """Scenario 5: VNC connection survives extended periodic screenshot polling.
+
+        Opens a VNC proxy connection and periodically takes screenshots over
+        a 5-minute window, simulating a user keeping VM overview and VNC console
+        open simultaneously.
+        """
+        with VNCConnection(vm=vm_for_vnc_screenshot) as vnc_child:
+            assert vnc_child, "Failed to establish VNC connection"
+            LOGGER.info("Starting extended screenshot polling for 5 minutes")
+            for sample in TimeoutSampler(
+                wait_timeout=TIMEOUT_5MIN,
+                sleep=TIMEOUT_30SEC,
+                func=vm_for_vnc_screenshot.vmi.api_request,
+                method="GET",
+                action="vnc/screenshot",
+            ):
+                assert vnc_child.isalive(), (
+                    "VNC connection dropped during extended screenshot polling"
+                )
+                if sample:
+                    LOGGER.info("Screenshot poll successful, VNC still connected")
+            LOGGER.info("Extended polling complete, VNC connection remained stable")
