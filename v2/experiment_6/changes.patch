diff --git a/tests/virt/node/hotplug/test_cpu_maxsockets_limits.py b/tests/virt/node/hotplug/test_cpu_maxsockets_limits.py
new file mode 100644
index 0000000..2a4a55c
--- /dev/null
+++ b/tests/virt/node/hotplug/test_cpu_maxsockets_limits.py
@@ -0,0 +1,298 @@
+"""
+Test CPU Hotplug MaxSockets Limiting
+
+This module tests the CPU hotplug MaxSockets limiting functionality to ensure that:
+- MaxSockets value is correctly calculated and limited based on the maximum vCPUs allowed
+- CPU hotplug operations are properly blocked when reaching the maximum limit
+- Appropriate error messages are displayed when attempting to exceed limits
+- Full CPU hotplug lifecycle works correctly with MaxSockets enforcement
+
+Test scenarios validate the fix from PR kubevirt/kubevirt#14511 which limits MaxSockets
+based on maximum allowed vCPUs to prevent resource overcommit.
+
+Related Jira: CNV-61263 (Feature), CNV-57352 (Bug Fix)
+"""
+
+import logging
+
+import pytest
+from kubernetes.dynamic.exceptions import UnprocessibleEntityError
+
+from tests.os_params import RHEL_LATEST, RHEL_LATEST_LABELS, WINDOWS_LATEST, WINDOWS_LATEST_LABELS
+from tests.utils import assert_guest_os_cpu_count, clean_up_migration_jobs, hotplug_spec_vm
+from utilities.constants import (
+    EIGHT_CPU_SOCKETS,
+    FOUR_CPU_SOCKETS,
+    FOUR_GI_MEMORY,
+    ONE_CPU_CORE,
+    ONE_CPU_THREAD,
+    SIX_CPU_SOCKETS,
+    TEN_CPU_SOCKETS,
+    TEN_GI_MEMORY,
+    TWO_CPU_SOCKETS,
+)
+from utilities.virt import (
+    VirtualMachineForTestsFromTemplate,
+    migrate_vm_and_verify,
+    restart_vm_wait_for_running_vm,
+    running_vm,
+)
+
+pytestmark = pytest.mark.rwx_default_storage
+
+LOGGER = logging.getLogger(__name__)
+TESTS_CLASS_NAME = "TestCPUMaxSocketsLimits"
+
+
+@pytest.fixture(scope="class")
+def maxsockets_vm(
+    request,
+    namespace,
+    unprivileged_client,
+    golden_image_data_volume_template_for_test_scope_class,
+    modern_cpu_for_migration,
+    vmx_disabled_flag,
+):
+    """
+    Creates a VM with CPU hotplug capabilities and MaxSockets configuration.
+
+    The VM is configured with:
+    - Initial sockets: 2
+    - Max sockets: 8
+    - Memory: 4Gi with max 10Gi for hotplug
+    """
+    with VirtualMachineForTestsFromTemplate(
+        name=request.param["vm_name"],
+        labels=request.param["template_labels"],
+        namespace=namespace.name,
+        client=unprivileged_client,
+        data_volume_template=golden_image_data_volume_template_for_test_scope_class,
+        cpu_max_sockets=EIGHT_CPU_SOCKETS,
+        memory_max_guest=TEN_GI_MEMORY,
+        cpu_sockets=TWO_CPU_SOCKETS,
+        cpu_threads=ONE_CPU_THREAD,
+        cpu_cores=ONE_CPU_CORE,
+        memory_guest=FOUR_GI_MEMORY,
+        cpu_model=modern_cpu_for_migration,
+        cpu_flags=vmx_disabled_flag,
+    ) as vm:
+        running_vm(vm=vm)
+        yield vm
+
+
+@pytest.fixture()
+def maxsockets_hotplug_operation(request, admin_client, maxsockets_vm):
+    """
+    Performs CPU hotplug operation and handles cleanup.
+
+    Accepts parameters:
+    - sockets: Target socket count
+    """
+    param = request.param
+    hotplug_spec_vm(vm=maxsockets_vm, sockets=param.get("sockets"))
+    yield
+    clean_up_migration_jobs(client=admin_client, vm=maxsockets_vm)
+
+
+@pytest.mark.parametrize(
+    "golden_image_data_source_for_test_scope_class, maxsockets_vm",
+    [
+        pytest.param(
+            {"os_dict": RHEL_LATEST},
+            {"template_labels": RHEL_LATEST_LABELS, "vm_name": "rhel-maxsockets-limits-vm"},
+            id="RHEL-VM",
+        ),
+        pytest.param(
+            {"os_dict": WINDOWS_LATEST},
+            {"template_labels": WINDOWS_LATEST_LABELS, "vm_name": "windows-maxsockets-limits-vm"},
+            id="WIN-VM",
+            marks=[pytest.mark.special_infra, pytest.mark.high_resource_vm],
+        ),
+    ],
+    indirect=True,
+)
+class TestCPUMaxSocketsLimits:
+    """
+    Test suite for CPU Hotplug MaxSockets limiting functionality.
+
+    Tests validate:
+    - TS-01: MaxSockets Calculation Verification (P0)
+    - TS-02: CPU Hotplug at Maximum Limit (P0)
+    - TS-03: Error Handling for Limit Violations (P1)
+    - TS-04: Full CPU Hotplug Lifecycle E2E (P1)
+    """
+
+    @pytest.mark.dependency(name=f"{TESTS_CLASS_NAME}::test_verify_maxsockets_configuration")
+    @pytest.mark.polarion("CNV-61263-01")
+    def test_verify_maxsockets_configuration(self, maxsockets_vm):
+        """
+        TS-01: Verify MaxSockets configuration is correct.
+
+        Validates that:
+        - VM is created with specified CPU configuration
+        - Initial CPU count (2 sockets) is correct
+        - MaxSockets value (8) is properly set
+        - Guest OS recognizes the correct initial CPU count
+
+        Priority: P0
+        Type: Functional/Tier 1
+        """
+        LOGGER.info("Verifying initial MaxSockets configuration")
+
+        # Verify VM CPU configuration
+        assert maxsockets_vm.instance.spec.template.spec.domain.cpu.sockets == TWO_CPU_SOCKETS, (
+            f"Expected initial sockets: {TWO_CPU_SOCKETS}, "
+            f"got: {maxsockets_vm.instance.spec.template.spec.domain.cpu.sockets}"
+        )
+        assert maxsockets_vm.instance.spec.template.spec.domain.cpu.maxSockets == EIGHT_CPU_SOCKETS, (
+            f"Expected maxSockets: {EIGHT_CPU_SOCKETS}, "
+            f"got: {maxsockets_vm.instance.spec.template.spec.domain.cpu.maxSockets}"
+        )
+
+        # Verify guest OS sees correct initial CPU count
+        assert_guest_os_cpu_count(vm=maxsockets_vm, spec_cpu_amount=TWO_CPU_SOCKETS)
+        LOGGER.info("MaxSockets configuration verified successfully")
+
+    @pytest.mark.parametrize(
+        "maxsockets_hotplug_operation",
+        [pytest.param({"sockets": FOUR_CPU_SOCKETS})],
+        indirect=True,
+    )
+    @pytest.mark.dependency(
+        name=f"{TESTS_CLASS_NAME}::test_hotplug_cpu_to_four_sockets",
+        depends=[f"{TESTS_CLASS_NAME}::test_verify_maxsockets_configuration"],
+    )
+    @pytest.mark.polarion("CNV-61263-02")
+    def test_hotplug_cpu_to_four_sockets(self, maxsockets_hotplug_operation, maxsockets_vm):
+        """
+        TS-04: First hotplug operation in lifecycle (2 to 4 CPUs).
+
+        Validates that:
+        - CPU hotplug from 2 to 4 sockets succeeds
+        - Guest OS recognizes the additional CPUs
+        - VM remains stable after hotplug
+
+        Priority: P1
+        Type: End-to-End/Tier 2
+        """
+        LOGGER.info("Testing hotplug from 2 to 4 CPU sockets")
+        assert_guest_os_cpu_count(vm=maxsockets_vm, spec_cpu_amount=FOUR_CPU_SOCKETS)
+        LOGGER.info("Successfully hotplugged to 4 CPU sockets")
+
+    @pytest.mark.parametrize(
+        "maxsockets_hotplug_operation",
+        [pytest.param({"sockets": SIX_CPU_SOCKETS})],
+        indirect=True,
+    )
+    @pytest.mark.dependency(
+        name=f"{TESTS_CLASS_NAME}::test_hotplug_cpu_to_six_sockets",
+        depends=[f"{TESTS_CLASS_NAME}::test_hotplug_cpu_to_four_sockets"],
+    )
+    @pytest.mark.polarion("CNV-61263-03")
+    def test_hotplug_cpu_to_six_sockets(self, maxsockets_hotplug_operation, maxsockets_vm):
+        """
+        TS-04: Second hotplug operation in lifecycle (4 to 6 CPUs).
+
+        Validates that:
+        - CPU hotplug from 4 to 6 sockets succeeds
+        - Guest OS recognizes the additional CPUs
+        - Sequential hotplug operations work correctly
+
+        Priority: P1
+        Type: End-to-End/Tier 2
+        """
+        LOGGER.info("Testing hotplug from 4 to 6 CPU sockets")
+        assert_guest_os_cpu_count(vm=maxsockets_vm, spec_cpu_amount=SIX_CPU_SOCKETS)
+        LOGGER.info("Successfully hotplugged to 6 CPU sockets")
+
+    @pytest.mark.parametrize(
+        "maxsockets_hotplug_operation",
+        [pytest.param({"sockets": EIGHT_CPU_SOCKETS})],
+        indirect=True,
+    )
+    @pytest.mark.dependency(
+        name=f"{TESTS_CLASS_NAME}::test_hotplug_cpu_to_maximum_limit",
+        depends=[f"{TESTS_CLASS_NAME}::test_hotplug_cpu_to_six_sockets"],
+    )
+    @pytest.mark.polarion("CNV-61263-04")
+    def test_hotplug_cpu_to_maximum_limit(self, maxsockets_hotplug_operation, maxsockets_vm):
+        """
+        TS-02: Hotplug to maximum limit (6 to 8 CPUs).
+
+        Validates that:
+        - CPU hotplug to maximum limit (8 sockets) succeeds
+        - Guest OS recognizes all 8 CPUs
+        - VM reaches maximum CPU configuration successfully
+
+        Priority: P0
+        Type: Functional/Tier 1
+        """
+        LOGGER.info("Testing hotplug to maximum limit (8 CPU sockets)")
+        assert_guest_os_cpu_count(vm=maxsockets_vm, spec_cpu_amount=EIGHT_CPU_SOCKETS)
+        LOGGER.info("Successfully reached maximum CPU limit")
+
+    @pytest.mark.dependency(
+        depends=[f"{TESTS_CLASS_NAME}::test_hotplug_cpu_to_maximum_limit"],
+    )
+    @pytest.mark.polarion("CNV-61263-05")
+    def test_hotplug_cpu_exceeding_maximum_limit(self, maxsockets_vm):
+        """
+        TS-03: Attempt to exceed maximum CPU limit.
+
+        Validates that:
+        - Attempting to hotplug beyond maxSockets (10 sockets) is rejected
+        - Appropriate error (UnprocessibleEntityError) is raised
+        - VM configuration remains at maximum (8 sockets)
+
+        Priority: P1
+        Type: Functional/Tier 1
+        """
+        LOGGER.info("Testing hotplug beyond maximum limit (attempting 10 sockets)")
+        with pytest.raises(UnprocessibleEntityError):
+            hotplug_spec_vm(vm=maxsockets_vm, sockets=TEN_CPU_SOCKETS)
+            pytest.fail("CPU socket value set higher than maxSockets limit!")
+        LOGGER.info("Correctly rejected hotplug beyond maximum limit")
+
+    @pytest.mark.dependency(
+        depends=[f"{TESTS_CLASS_NAME}::test_hotplug_cpu_exceeding_maximum_limit"],
+    )
+    @pytest.mark.polarion("CNV-61263-06")
+    def test_migrate_vm_at_maximum_cpus(self, maxsockets_vm):
+        """
+        TS-04: Migrate VM at maximum CPU configuration.
+
+        Validates that:
+        - VM can be migrated while at maximum CPU count
+        - Migration completes successfully
+        - SSH connectivity is maintained after migration
+        - CPU count remains correct after migration
+
+        Priority: P1
+        Type: End-to-End/Tier 2
+        """
+        LOGGER.info("Testing VM migration at maximum CPU configuration")
+        migrate_vm_and_verify(vm=maxsockets_vm, check_ssh_connectivity=True)
+        assert_guest_os_cpu_count(vm=maxsockets_vm, spec_cpu_amount=EIGHT_CPU_SOCKETS)
+        LOGGER.info("VM migrated successfully at maximum CPU count")
+
+    @pytest.mark.dependency(
+        depends=[f"{TESTS_CLASS_NAME}::test_migrate_vm_at_maximum_cpus"],
+    )
+    @pytest.mark.polarion("CNV-61263-07")
+    def test_restart_vm_at_maximum_cpus(self, maxsockets_vm):
+        """
+        TS-04: Restart VM at maximum CPU configuration.
+
+        Validates that:
+        - VM can be stopped and restarted while at maximum CPU count
+        - VM boots successfully with 8 CPUs
+        - Guest OS recognizes all CPUs after restart
+        - MaxSockets limit is maintained across restart
+
+        Priority: P1
+        Type: End-to-End/Tier 2
+        """
+        LOGGER.info("Testing VM restart at maximum CPU configuration")
+        restart_vm_wait_for_running_vm(vm=maxsockets_vm)
+        assert_guest_os_cpu_count(vm=maxsockets_vm, spec_cpu_amount=EIGHT_CPU_SOCKETS)
+        LOGGER.info("VM restarted successfully with maximum CPU count")
