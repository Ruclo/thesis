diff --git a/tests/virt/node/general/test_vmi_hard_reset.py b/tests/virt/node/general/test_vmi_hard_reset.py
new file mode 100644
index 0000000..a9c8dc4
--- /dev/null
+++ b/tests/virt/node/general/test_vmi_hard_reset.py
@@ -0,0 +1,313 @@
+"""
+Test Suite for VMI Hard Reset Functionality (VIRTSTRAT-357)
+
+This test suite covers the Force/Hard Reset feature for VirtualMachineInstance objects.
+The hard reset functionality provides a faster, in-place alternative to VM restart that:
+- Simulates pressing the hardware reset button on a physical machine
+- Does not require pod rescheduling
+- Preserves VMI UID and pod assignment
+- Provides an immediate recovery path for hung guests
+"""
+
+import logging
+import shlex
+
+import pytest
+from kubernetes.dynamic.exceptions import ForbiddenError, NotFoundError
+from ocp_resources.cluster_role import ClusterRole
+from ocp_resources.role_binding import RoleBinding
+from ocp_resources.virtual_machine import VirtualMachine
+from pyhelper_utils.shell import run_ssh_commands
+
+from utilities.constants import UNPRIVILEGED_USER
+from utilities.virt import VirtualMachineForTests, fedora_vm_body, running_vm, wait_for_running_vm
+
+LOGGER = logging.getLogger(__name__)
+
+
+def get_vm_boot_count(vm: VirtualMachineForTests) -> int:
+    """
+    Get the number of times the VM has booted.
+
+    Args:
+        vm: VirtualMachineForTests instance
+
+    Returns:
+        int: Number of boot entries from journalctl
+    """
+    reboot_count = run_ssh_commands(
+        host=vm.ssh_exec,
+        commands=[shlex.split("journalctl --list-boots | wc -l")],
+    )[0].strip()
+
+    return int(reboot_count)
+
+
+def get_vmi_uid(vm: VirtualMachineForTests) -> str:
+    """
+    Get the VMI UID.
+
+    Args:
+        vm: VirtualMachineForTests instance
+
+    Returns:
+        str: VMI UID
+    """
+    return vm.vmi.instance.metadata.uid
+
+
+@pytest.fixture(scope="class")
+def vm_for_reset_test(namespace, unprivileged_client):
+    """
+    Create a VM for reset testing.
+
+    Args:
+        namespace: Test namespace fixture
+        unprivileged_client: Unprivileged client fixture
+
+    Yields:
+        VirtualMachineForTests: VM instance ready for reset testing
+    """
+    vm_name = "vm-for-hard-reset-test"
+    with VirtualMachineForTests(
+        client=unprivileged_client,
+        name=vm_name,
+        body=fedora_vm_body(name=vm_name),
+        namespace=namespace.name,
+    ) as vm:
+        running_vm(vm=vm)
+        yield vm
+
+
+@pytest.fixture(scope="class")
+def vm_for_rbac_reset_test(namespace, unprivileged_client):
+    """
+    Create a VM for RBAC reset testing.
+
+    Args:
+        namespace: Test namespace fixture
+        unprivileged_client: Unprivileged client fixture
+
+    Yields:
+        VirtualMachineForTests: VM instance ready for RBAC testing
+    """
+    vm_name = "vm-for-rbac-reset-test"
+    with VirtualMachineForTests(
+        client=unprivileged_client,
+        name=vm_name,
+        body=fedora_vm_body(name=vm_name),
+        namespace=namespace.name,
+    ) as vm:
+        running_vm(vm=vm)
+        yield vm
+
+
+@pytest.fixture(scope="class")
+def stopped_vm_for_reset_test(namespace, unprivileged_client):
+    """
+    Create a stopped VM for negative reset testing.
+
+    Args:
+        namespace: Test namespace fixture
+        unprivileged_client: Unprivileged client fixture
+
+    Yields:
+        VirtualMachineForTests: Stopped VM instance
+    """
+    vm_name = "stopped-vm-for-reset-test"
+    with VirtualMachineForTests(
+        client=unprivileged_client,
+        name=vm_name,
+        body=fedora_vm_body(name=vm_name),
+        namespace=namespace.name,
+    ) as vm:
+        vm.stop(wait=True)
+        yield vm
+
+
+@pytest.fixture()
+def kubevirt_reset_cluster_role(admin_client):
+    """
+    Get the kubevirt.io:reset ClusterRole.
+
+    Args:
+        admin_client: Admin client fixture
+
+    Returns:
+        ClusterRole: The reset ClusterRole
+    """
+    return ClusterRole(name="kubevirt.io:edit", client=admin_client, ensure_exists=True)
+
+
+@pytest.fixture()
+def unprivileged_user_reset_rolebinding(
+    admin_client,
+    namespace,
+    kubevirt_reset_cluster_role,
+):
+    """
+    Create RoleBinding to grant reset permissions to unprivileged user.
+
+    Args:
+        admin_client: Admin client fixture
+        namespace: Test namespace fixture
+        kubevirt_reset_cluster_role: Reset ClusterRole fixture
+
+    Yields:
+        RoleBinding: RoleBinding granting reset permissions
+    """
+    with RoleBinding(
+        name="role-bind-kubevirt-reset",
+        namespace=namespace.name,
+        client=admin_client,
+        subjects_kind="User",
+        subjects_name=UNPRIVILEGED_USER,
+        subjects_namespace=namespace.name,
+        role_ref_kind=kubevirt_reset_cluster_role.kind,
+        role_ref_name=kubevirt_reset_cluster_role.name,
+    ) as role_binding:
+        yield role_binding
+
+
+@pytest.mark.parametrize(
+    "vm_for_reset_test",
+    [pytest.param("vm-for-hard-reset-basic-test")],
+    indirect=True,
+)
+class TestVMIHardResetBasic:
+    """Basic VMI Hard Reset functionality tests."""
+
+    @pytest.mark.polarion("CNV-12373")
+    def test_reset_running_vmi_via_api(self, vm_for_reset_test):
+        """
+        TS-01: Reset running VMI via API and verify guest reboots.
+
+        This test verifies:
+        - VMI reset API endpoint functions correctly for running VMIs
+        - Guest actually reboots after reset (boot count increases)
+        """
+        boot_count_before = get_vm_boot_count(vm=vm_for_reset_test)
+        LOGGER.info(f"Boot count before reset: {boot_count_before}")
+
+        vm_for_reset_test.vmi.reset()
+        wait_for_running_vm(vm=vm_for_reset_test)
+
+        boot_count_after = get_vm_boot_count(vm=vm_for_reset_test)
+        LOGGER.info(f"Boot count after reset: {boot_count_after}")
+
+        assert boot_count_after - boot_count_before == 1, (
+            f"Expected boot count to increase by 1 after reset. "
+            f"Before: {boot_count_before}, After: {boot_count_after}"
+        )
+
+    @pytest.mark.polarion("CNV-12374")
+    def test_vmi_uid_unchanged_after_reset(self, vm_for_reset_test):
+        """
+        TS-03: Verify VMI UID remains unchanged after reset.
+
+        This test verifies:
+        - Reset does not cause pod rescheduling
+        - VMI UID is preserved after reset
+        """
+        uid_before = get_vmi_uid(vm=vm_for_reset_test)
+        LOGGER.info(f"VMI UID before reset: {uid_before}")
+
+        vm_for_reset_test.vmi.reset()
+        wait_for_running_vm(vm=vm_for_reset_test)
+
+        uid_after = get_vmi_uid(vm=vm_for_reset_test)
+        LOGGER.info(f"VMI UID after reset: {uid_after}")
+
+        assert uid_before == uid_after, (
+            f"VMI UID changed after reset. Before: {uid_before}, After: {uid_after}"
+        )
+
+    @pytest.mark.polarion("CNV-12375")
+    def test_boot_time_changes_after_reset(self, vm_for_reset_test):
+        """
+        TS-11: Verify boot time changes after reset.
+
+        This test verifies:
+        - Reset triggers actual guest reboot
+        - Guest boot time is updated after reset
+        """
+        boot_count_before = get_vm_boot_count(vm=vm_for_reset_test)
+
+        vm_for_reset_test.vmi.reset()
+        wait_for_running_vm(vm=vm_for_reset_test)
+
+        boot_count_after = get_vm_boot_count(vm=vm_for_reset_test)
+
+        assert boot_count_after > boot_count_before, (
+            f"Boot count did not increase after reset. "
+            f"Before: {boot_count_before}, After: {boot_count_after}"
+        )
+
+
+class TestVMIHardResetNegative:
+    """Negative test cases for VMI Hard Reset."""
+
+    @pytest.mark.polarion("CNV-12376")
+    def test_reset_stopped_vmi_fails(self, stopped_vm_for_reset_test):
+        """
+        TS-05: Verify reset fails on non-running VMI with appropriate error.
+
+        This test verifies:
+        - Reset operation fails gracefully on non-running VMIs
+        - Appropriate error is returned
+        """
+        with pytest.raises(Exception) as exc_info:
+            stopped_vm_for_reset_test.vmi.reset()
+
+        LOGGER.info(f"Expected exception raised: {exc_info.value}")
+        assert exc_info.value is not None, "Reset should fail on stopped VMI"
+
+    @pytest.mark.polarion("CNV-12377")
+    def test_reset_non_existent_vmi_fails(self, namespace, unprivileged_client):
+        """
+        TS-06: Verify reset fails on non-existent VMI.
+
+        This test verifies:
+        - Reset operation fails when VMI doesn't exist
+        - Appropriate error is returned
+        """
+        non_existent_vm = VirtualMachine(
+            name="non-existent-vm",
+            namespace=namespace.name,
+            client=unprivileged_client,
+        )
+
+        with pytest.raises((NotFoundError, AttributeError)) as exc_info:
+            non_existent_vm.vmi.reset()
+
+        LOGGER.info(f"Expected exception raised: {exc_info.value}")
+        assert exc_info.value is not None, "Reset should fail on non-existent VMI"
+
+
+class TestVMIHardResetRBAC:
+    """RBAC tests for VMI Hard Reset."""
+
+    @pytest.mark.polarion("CNV-12378")
+    @pytest.mark.usefixtures("unprivileged_user_reset_rolebinding")
+    def test_unprivileged_user_can_reset_with_permissions(
+        self,
+        vm_for_rbac_reset_test,
+    ):
+        """
+        TS-04: Verify RBAC: user with edit role can reset VMI.
+
+        This test verifies:
+        - Appropriate RBAC permissions are enforced
+        - User with edit role can perform reset operation
+        """
+        boot_count_before = get_vm_boot_count(vm=vm_for_rbac_reset_test)
+
+        vm_for_rbac_reset_test.vmi.reset()
+        wait_for_running_vm(vm=vm_for_rbac_reset_test)
+
+        boot_count_after = get_vm_boot_count(vm=vm_for_rbac_reset_test)
+
+        assert boot_count_after - boot_count_before == 1, (
+            f"Expected boot count to increase by 1 after reset. "
+            f"Before: {boot_count_before}, After: {boot_count_after}"
+        )
