diff --git a/tests/storage/snapshots/conftest.py b/tests/storage/snapshots/conftest.py
index 4db9193..8fa627b 100644
--- a/tests/storage/snapshots/conftest.py
+++ b/tests/storage/snapshots/conftest.py
@@ -9,9 +9,14 @@ import shlex
 
 import pytest
 from ocp_resources.datavolume import DataVolume
+from ocp_resources.resource import ResourceEditor
 from ocp_resources.role_binding import RoleBinding
+from ocp_resources.storage_class import StorageClass
+from ocp_resources.storage_profile import StorageProfile
 from ocp_resources.virtual_machine_snapshot import VirtualMachineSnapshot
+from ocp_resources.volume_snapshot_class import VolumeSnapshotClass
 from pyhelper_utils.shell import run_ssh_commands
+from timeout_sampler import TimeoutSampler
 
 from tests.storage.snapshots.constants import WINDOWS_DIRECTORY_PATH
 from tests.storage.utils import (
@@ -20,7 +25,7 @@ from tests.storage.utils import (
     create_windows_directory,
     set_permissions,
 )
-from utilities.constants import TIMEOUT_10MIN, UNPRIVILEGED_USER
+from utilities.constants import TIMEOUT_1MIN, TIMEOUT_5SEC, TIMEOUT_10MIN, UNPRIVILEGED_USER
 
 LOGGER = logging.getLogger(__name__)
 
@@ -106,3 +111,66 @@ def file_created_during_snapshot(windows_vm_for_snapshot, windows_snapshot):
     run_ssh_commands(host=windows_vm_for_snapshot.ssh_exec, commands=cmd)
     windows_snapshot.wait_snapshot_done(timeout=TIMEOUT_10MIN)
     windows_vm_for_snapshot.stop(wait=True)
+
+
+@pytest.fixture()
+def volume_snapshot_class_for_snapshot_sc(admin_client, snapshot_storage_class_name_scope_module):
+    """VolumeSnapshotClass matching the snapshot-capable StorageClass provisioner."""
+    sc_instance = StorageClass(
+        client=admin_client,
+        name=snapshot_storage_class_name_scope_module,
+    ).instance
+    provisioner = sc_instance.get("provisioner")
+    for vsc in VolumeSnapshotClass.get(client=admin_client):
+        if vsc.instance.get("driver") == provisioner:
+            return vsc
+    pytest.fail(f"No VolumeSnapshotClass found matching provisioner {provisioner}")
+
+
+@pytest.fixture()
+def storage_profile_with_snapshot_class(
+    admin_client,
+    snapshot_storage_class_name_scope_module,
+    volume_snapshot_class_for_snapshot_sc,
+):
+    """StorageProfile with snapshotClass set to the matching VolumeSnapshotClass.
+
+    Uses ResourceEditor to temporarily set the snapshotClass field and waits
+    for CDI to reconcile the status before yielding.
+    """
+    storage_profile = StorageProfile(
+        name=snapshot_storage_class_name_scope_module,
+        client=admin_client,
+    )
+    vsc_name = volume_snapshot_class_for_snapshot_sc.name
+    with ResourceEditor(patches={storage_profile: {"spec": {"snapshotClass": vsc_name}}}):
+        LOGGER.info(
+            f"Waiting for StorageProfile {snapshot_storage_class_name_scope_module} "
+            f"status.snapshotClass to equal {vsc_name}"
+        )
+        for sample in TimeoutSampler(
+            wait_timeout=TIMEOUT_1MIN,
+            sleep=TIMEOUT_5SEC,
+            func=lambda: storage_profile.snapshotclass == vsc_name,
+        ):
+            if sample:
+                break
+        yield storage_profile
+
+
+@pytest.fixture()
+def storage_profile_without_snapshot_class(admin_client, snapshot_storage_class_name_scope_module):
+    """StorageProfile with spec.snapshotClass temporarily cleared.
+
+    Uses ResourceEditor to set spec.snapshotClass to empty string, which the
+    kubevirt snapshot controller treats as not set. CDI may still auto-populate
+    status.snapshotClass via VolumeSnapshotClass driver matching, so this
+    fixture does not wait for status reconciliation.
+    """
+    storage_profile = StorageProfile(
+        name=snapshot_storage_class_name_scope_module,
+        client=admin_client,
+    )
+    LOGGER.info(f"Clearing spec.snapshotClass on StorageProfile {snapshot_storage_class_name_scope_module}")
+    with ResourceEditor(patches={storage_profile: {"spec": {"snapshotClass": ""}}}):
+        yield storage_profile
diff --git a/tests/storage/snapshots/test_storage_profile_snapshot_class.py b/tests/storage/snapshots/test_storage_profile_snapshot_class.py
new file mode 100644
index 0000000..a4ef557
--- /dev/null
+++ b/tests/storage/snapshots/test_storage_profile_snapshot_class.py
@@ -0,0 +1,222 @@
+# -*- coding: utf-8 -*-
+
+"""
+StorageProfile snapshotClass Honored for VM Snapshot Tests
+
+STP Reference: ../stps/5.md
+Jira: CNV-61266 / CNV-54866
+
+This module contains tests verifying that VMSnapshot honors the snapshotClass
+field from StorageProfile when selecting a VolumeSnapshotClass for snapshot
+creation. Prior to the fix, the snapshotClass setting was ignored and snapshots
+would use a VolumeSnapshotClass selected via labels instead.
+"""
+
+import logging
+
+import pytest
+from ocp_resources.virtual_machine_restore import VirtualMachineRestore
+from ocp_resources.virtual_machine_snapshot import VirtualMachineSnapshot
+from ocp_resources.volume_snapshot import VolumeSnapshot
+
+from utilities.virt import running_vm
+
+LOGGER = logging.getLogger(__name__)
+
+
+pytestmark = pytest.mark.usefixtures(
+    "namespace",
+    "skip_if_no_storage_class_for_snapshot",
+)
+
+
+class TestStorageProfileSnapshotClass:
+    """
+    Tests for StorageProfile snapshotClass selection during VM snapshot creation.
+
+    Preconditions:
+        - Cluster has snapshot-capable storage backend
+        - StorageClass exists with a matching VolumeSnapshotClass
+        - StorageProfile for the StorageClass has snapshotClass field set
+          to a specific VolumeSnapshotClass name
+        - Running RHEL VM created using the StorageClass
+    """
+
+    @pytest.mark.parametrize(
+        "rhel_vm_name",
+        [
+            pytest.param(
+                {"vm_name": "vm-cnv-61266-sp-class"},
+                marks=pytest.mark.polarion("CNV-61266"),
+            ),
+        ],
+        indirect=True,
+    )
+    @pytest.mark.usefixtures("storage_profile_with_snapshot_class")
+    def test_snapshot_uses_storage_profile_snapshot_class(
+        self,
+        admin_client,
+        namespace,
+        rhel_vm_for_snapshot,
+        volume_snapshot_class_for_snapshot_sc,
+    ):
+        """
+        Test that VMSnapshot uses the snapshotClass defined in StorageProfile.
+
+        Steps:
+            1. Stop the VM for offline snapshot
+            2. Create a VMSnapshot and wait for it to become ready
+            3. Retrieve VolumeSnapshots created by the VMSnapshot
+            4. Read the volumeSnapshotClassName from each VolumeSnapshot spec
+
+        Expected:
+            - VolumeSnapshot volumeSnapshotClassName equals the snapshotClass
+              value from StorageProfile
+        """
+        rhel_vm_for_snapshot.stop(wait=True)
+        expected_class = volume_snapshot_class_for_snapshot_sc.name
+        LOGGER.info(f"Creating VMSnapshot, expecting VolumeSnapshotClass: {expected_class}")
+        with VirtualMachineSnapshot(
+            name="snapshot-cnv-61266-sp-class",
+            namespace=rhel_vm_for_snapshot.namespace,
+            vm_name=rhel_vm_for_snapshot.name,
+            client=admin_client,
+        ) as vm_snapshot:
+            vm_snapshot.wait_snapshot_done()
+            volume_snapshots = list(
+                VolumeSnapshot.get(
+                    client=admin_client,
+                    namespace=namespace.name,
+                )
+            )
+            assert volume_snapshots, "No VolumeSnapshots found after VMSnapshot creation"
+            for volume_snapshot in volume_snapshots:
+                actual_class = volume_snapshot.instance.spec.volumeSnapshotClassName
+                LOGGER.info(f"VolumeSnapshot {volume_snapshot.name} uses VolumeSnapshotClass: {actual_class}")
+                assert actual_class == expected_class, (
+                    f"VolumeSnapshot {volume_snapshot.name} uses class {actual_class}, "
+                    f"expected {expected_class} from StorageProfile snapshotClass"
+                )
+
+    @pytest.mark.parametrize(
+        "rhel_vm_name",
+        [
+            pytest.param(
+                {"vm_name": "vm-cnv-54866-restore"},
+                marks=pytest.mark.polarion("CNV-54866"),
+            ),
+        ],
+        indirect=True,
+    )
+    @pytest.mark.usefixtures("storage_profile_with_snapshot_class")
+    def test_restore_vm_from_snapshot_with_storage_profile_snapshot_class(
+        self,
+        admin_client,
+        rhel_vm_for_snapshot,
+    ):
+        """
+        Test that a VM can be restored from a snapshot created with
+        StorageProfile-specified snapshotClass.
+
+        Steps:
+            1. Stop the VM
+            2. Create a VMSnapshot and wait for it to become ready
+            3. Restore the VM from the snapshot
+            4. Wait for restore to complete
+            5. Start the VM and wait for it to become running and SSH accessible
+
+        Expected:
+            - VM is "Running" and SSH accessible after restore
+        """
+        rhel_vm_for_snapshot.stop(wait=True)
+        LOGGER.info("Creating VMSnapshot for restore test")
+        with VirtualMachineSnapshot(
+            name="snapshot-cnv-61266-restore",
+            namespace=rhel_vm_for_snapshot.namespace,
+            vm_name=rhel_vm_for_snapshot.name,
+            client=admin_client,
+        ) as vm_snapshot:
+            vm_snapshot.wait_snapshot_done()
+            LOGGER.info(f"Restoring VM from snapshot {vm_snapshot.name}")
+            with VirtualMachineRestore(
+                client=admin_client,
+                name="restore-cnv-61266",
+                namespace=rhel_vm_for_snapshot.namespace,
+                vm_name=rhel_vm_for_snapshot.name,
+                snapshot_name=vm_snapshot.name,
+            ) as vm_restore:
+                vm_restore.wait_restore_done()
+                running_vm(vm=rhel_vm_for_snapshot)
+
+
+class TestStorageProfileSnapshotClassFallback:
+    """
+    Tests for fallback VolumeSnapshotClass selection when StorageProfile
+    has no snapshotClass configured.
+
+    Preconditions:
+        - Cluster has snapshot-capable storage backend
+        - StorageClass exists with a matching VolumeSnapshotClass
+        - StorageProfile for the StorageClass does NOT have snapshotClass set
+        - Running RHEL VM created using the StorageClass
+    """
+
+    @pytest.mark.parametrize(
+        "rhel_vm_name",
+        [
+            pytest.param(
+                {"vm_name": "vm-cnv-61267-fallback"},
+                marks=pytest.mark.polarion("CNV-61267"),
+            ),
+        ],
+        indirect=True,
+    )
+    @pytest.mark.usefixtures("storage_profile_without_snapshot_class")
+    def test_snapshot_falls_back_to_label_based_selection(
+        self,
+        admin_client,
+        namespace,
+        rhel_vm_for_snapshot,
+        volume_snapshot_class_for_snapshot_sc,
+    ):
+        """
+        Test that VMSnapshot falls back to label-based VolumeSnapshotClass
+        selection when StorageProfile has no snapshotClass.
+
+        Steps:
+            1. Stop the VM for offline snapshot
+            2. Create a VMSnapshot and wait for it to become ready
+            3. Retrieve VolumeSnapshots created by the VMSnapshot
+            4. Read the volumeSnapshotClassName from each VolumeSnapshot spec
+
+        Expected:
+            - VolumeSnapshot volumeSnapshotClassName equals the
+              VolumeSnapshotClass whose driver matches the StorageClass
+              provisioner (label-based default selection)
+        """
+        rhel_vm_for_snapshot.stop(wait=True)
+        expected_class = volume_snapshot_class_for_snapshot_sc.name
+        LOGGER.info(
+            f"Creating VMSnapshot without snapshotClass, expecting label-based VolumeSnapshotClass: {expected_class}"
+        )
+        with VirtualMachineSnapshot(
+            name="snapshot-cnv-61266-fallback",
+            namespace=rhel_vm_for_snapshot.namespace,
+            vm_name=rhel_vm_for_snapshot.name,
+            client=admin_client,
+        ) as vm_snapshot:
+            vm_snapshot.wait_snapshot_done()
+            volume_snapshots = list(
+                VolumeSnapshot.get(
+                    client=admin_client,
+                    namespace=namespace.name,
+                )
+            )
+            assert volume_snapshots, "No VolumeSnapshots found after VMSnapshot creation"
+            for volume_snapshot in volume_snapshots:
+                actual_class = volume_snapshot.instance.spec.volumeSnapshotClassName
+                LOGGER.info(f"VolumeSnapshot {volume_snapshot.name} uses VolumeSnapshotClass: {actual_class}")
+                assert actual_class == expected_class, (
+                    f"VolumeSnapshot {volume_snapshot.name} uses class {actual_class}, "
+                    f"expected {expected_class} from label-based selection"
+                )
