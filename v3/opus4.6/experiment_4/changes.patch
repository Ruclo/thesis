diff --git a/tests/storage/snapshots/conftest.py b/tests/storage/snapshots/conftest.py
index 4db9193..307f3f9 100644
--- a/tests/storage/snapshots/conftest.py
+++ b/tests/storage/snapshots/conftest.py
@@ -10,6 +10,13 @@ import shlex
 import pytest
 from ocp_resources.datavolume import DataVolume
 from ocp_resources.role_binding import RoleBinding
+from ocp_resources.virtual_machine_cluster_instancetype import (
+    VirtualMachineClusterInstancetype,
+)
+from ocp_resources.virtual_machine_cluster_preference import (
+    VirtualMachineClusterPreference,
+)
+from ocp_resources.virtual_machine_restore import VirtualMachineRestore
 from ocp_resources.virtual_machine_snapshot import VirtualMachineSnapshot
 from pyhelper_utils.shell import run_ssh_commands
 
@@ -20,7 +27,15 @@ from tests.storage.utils import (
     create_windows_directory,
     set_permissions,
 )
-from utilities.constants import TIMEOUT_10MIN, UNPRIVILEGED_USER
+from utilities.constants import (
+    OS_FLAVOR_RHEL,
+    RHEL10_PREFERENCE,
+    TIMEOUT_10MIN,
+    U1_SMALL,
+    UNPRIVILEGED_USER,
+)
+from utilities.storage import data_volume_template_with_source_ref_dict, write_file_via_ssh
+from utilities.virt import VirtualMachineForTests, running_vm
 
 LOGGER = logging.getLogger(__name__)
 
@@ -106,3 +121,95 @@ def file_created_during_snapshot(windows_vm_for_snapshot, windows_snapshot):
     run_ssh_commands(host=windows_vm_for_snapshot.ssh_exec, commands=cmd)
     windows_snapshot.wait_snapshot_done(timeout=TIMEOUT_10MIN)
     windows_vm_for_snapshot.stop(wait=True)
+
+
+@pytest.fixture()
+def vm_for_snapshot_with_run_strategy(
+    request,
+    admin_client,
+    namespace,
+    rhel10_data_source_scope_session,
+    snapshot_storage_class_name_scope_module,
+):
+    """RHEL VM with configurable runStrategy for snapshot restore testing."""
+    with VirtualMachineForTests(
+        name=request.param["vm_name"],
+        namespace=namespace.name,
+        client=admin_client,
+        os_flavor=OS_FLAVOR_RHEL,
+        run_strategy=request.param["run_strategy"],
+        vm_instance_type=VirtualMachineClusterInstancetype(client=admin_client, name=U1_SMALL),
+        vm_preference=VirtualMachineClusterPreference(client=admin_client, name=RHEL10_PREFERENCE),
+        data_volume_template=data_volume_template_with_source_ref_dict(
+            data_source=rhel10_data_source_scope_session,
+            storage_class=snapshot_storage_class_name_scope_module,
+        ),
+    ) as vm:
+        running_vm(vm=vm)
+        yield vm
+
+
+@pytest.fixture()
+def vm_snapshot_ready(admin_client, vm_for_snapshot_with_run_strategy):
+    """Snapshot from running VM, VM stopped after snapshot is ready."""
+    vm = vm_for_snapshot_with_run_strategy
+    with VirtualMachineSnapshot(
+        name=f"snapshot-{vm.name}",
+        namespace=vm.namespace,
+        vm_name=vm.name,
+        client=admin_client,
+    ) as snapshot:
+        snapshot.wait_snapshot_done()
+        vm.stop(wait=True)
+        yield snapshot
+
+
+@pytest.fixture()
+def restored_vm_with_data(admin_client, vm_for_snapshot_with_run_strategy):
+    """VM with pre-snapshot data written, restored from snapshot, and started."""
+    vm = vm_for_snapshot_with_run_strategy
+    LOGGER.info(f"Writing pre-snapshot data to VM {vm.name}")
+    write_file_via_ssh(vm=vm, filename="original.txt", content="data-before-snapshot")
+    with VirtualMachineSnapshot(
+        name=f"data-snapshot-{vm.name}",
+        namespace=vm.namespace,
+        vm_name=vm.name,
+        client=admin_client,
+    ) as snapshot:
+        snapshot.wait_snapshot_done()
+        LOGGER.info(f"Writing post-snapshot data to VM {vm.name}")
+        write_file_via_ssh(vm=vm, filename="after.txt", content="post-snapshot-data")
+        vm.stop(wait=True)
+        LOGGER.info(f"Restoring VM {vm.name} from snapshot {snapshot.name}")
+        with VirtualMachineRestore(
+            client=admin_client,
+            name=f"restore-data-{vm.name}",
+            namespace=vm.namespace,
+            vm_name=vm.name,
+            snapshot_name=snapshot.name,
+        ) as restore:
+            restore.wait_restore_done()
+            running_vm(vm=vm)
+            yield vm
+
+
+@pytest.fixture()
+def multiple_snapshots_for_restore(admin_client, vm_for_snapshot_with_run_strategy):
+    """Three snapshots taken at different points, VM stopped after creation."""
+    vm = vm_for_snapshot_with_run_strategy
+    snapshots = []
+    for idx in range(1, 4):
+        write_file_via_ssh(vm=vm, filename=f"file-{idx}.txt", content=f"content-{idx}")
+        with VirtualMachineSnapshot(
+            name=f"multi-snapshot-{vm.name}-{idx}",
+            namespace=vm.namespace,
+            vm_name=vm.name,
+            client=admin_client,
+            teardown=False,
+        ) as snapshot:
+            snapshots.append(snapshot)
+            snapshot.wait_snapshot_done()
+    vm.stop(wait=True)
+    yield snapshots
+    for snapshot in snapshots:
+        snapshot.clean_up()
diff --git a/tests/storage/snapshots/test_snapshot_restore_run_strategy.py b/tests/storage/snapshots/test_snapshot_restore_run_strategy.py
new file mode 100644
index 0000000..5a075ff
--- /dev/null
+++ b/tests/storage/snapshots/test_snapshot_restore_run_strategy.py
@@ -0,0 +1,428 @@
+# -*- coding: utf-8 -*-
+
+"""
+VM Snapshot Restore with runStrategy RerunOnFailure Tests
+
+STP Reference: ../stps/4.md
+Jira: CNV-63819
+
+This module contains tests for VM snapshot restore across different run strategies,
+with focus on the RerunOnFailure strategy where restore previously got stuck due to
+virt-controller prematurely starting the VM during the restore operation.
+"""
+
+import logging
+import shlex
+
+import pytest
+from ocp_resources.virtual_machine import VirtualMachine
+from ocp_resources.virtual_machine_instance import VirtualMachineInstance
+from ocp_resources.virtual_machine_restore import VirtualMachineRestore
+from pyhelper_utils.shell import run_ssh_commands
+from timeout_sampler import TimeoutSampler
+
+from utilities.constants import TIMEOUT_5MIN, TIMEOUT_5SEC
+from utilities.virt import running_vm
+
+LOGGER = logging.getLogger(__name__)
+
+
+pytestmark = pytest.mark.usefixtures(
+    "namespace",
+    "skip_if_no_storage_class_for_snapshot",
+)
+
+
+class TestSnapshotRestoreRerunOnFailure:
+    """
+    Tests for snapshot restore with runStrategy: RerunOnFailure.
+
+    Validates the fix for CNV-63819 where snapshot restore gets stuck because
+    virt-controller attempts to start the VM during the restore operation.
+    """
+
+    @pytest.mark.jira("CNV-63819")
+    @pytest.mark.parametrize(
+        "vm_for_snapshot_with_run_strategy",
+        [
+            pytest.param(
+                {
+                    "vm_name": "vm-cnv-63819-restore",
+                    "run_strategy": VirtualMachine.RunStrategy.RERUNONFAILURE,
+                },
+            ),
+        ],
+        indirect=True,
+    )
+    def test_snapshot_restore_completes(
+        self,
+        admin_client,
+        vm_for_snapshot_with_run_strategy,
+        vm_snapshot_ready,
+    ):
+        """
+        Test that snapshot restore completes for VM with runStrategy RerunOnFailure.
+
+        Steps:
+            1. Create VirtualMachineRestore from the snapshot
+            2. Wait for restore to reach terminal state
+
+        Expected:
+            - VirtualMachineRestore status is "Complete"
+        """
+        vm = vm_for_snapshot_with_run_strategy
+        LOGGER.info(f"Restoring VM {vm.name} from snapshot {vm_snapshot_ready.name}")
+        with VirtualMachineRestore(
+            client=admin_client,
+            name=f"restore-{vm.name}",
+            namespace=vm.namespace,
+            vm_name=vm.name,
+            snapshot_name=vm_snapshot_ready.name,
+        ) as vm_restore:
+            vm_restore.wait_restore_done()
+            assert vm_restore.instance.status.get("complete"), (
+                f"VirtualMachineRestore {vm_restore.name} did not reach Complete status"
+            )
+
+    @pytest.mark.jira("CNV-63819")
+    @pytest.mark.parametrize(
+        "vm_for_snapshot_with_run_strategy",
+        [
+            pytest.param(
+                {
+                    "vm_name": "vm-cnv-63819-no-autostart",
+                    "run_strategy": VirtualMachine.RunStrategy.RERUNONFAILURE,
+                },
+            ),
+        ],
+        indirect=True,
+    )
+    def test_vm_not_auto_started_during_restore(
+        self,
+        admin_client,
+        vm_for_snapshot_with_run_strategy,
+        vm_snapshot_ready,
+    ):
+        """
+        Test that VM does not auto-start during snapshot restore with RerunOnFailure.
+
+        Steps:
+            1. Create VirtualMachineRestore from the snapshot
+            2. While restore is in progress, check for VirtualMachineInstance existence
+
+        Expected:
+            - No VirtualMachineInstance resource exists for the VM during restore
+        """
+        vm = vm_for_snapshot_with_run_strategy
+        LOGGER.info(f"Restoring VM {vm.name} and verifying no VMI is created during restore")
+        with VirtualMachineRestore(
+            client=admin_client,
+            name=f"restore-{vm.name}",
+            namespace=vm.namespace,
+            vm_name=vm.name,
+            snapshot_name=vm_snapshot_ready.name,
+        ) as vm_restore:
+            for sample in TimeoutSampler(
+                wait_timeout=TIMEOUT_5MIN,
+                sleep=TIMEOUT_5SEC,
+                func=lambda: vm_restore.instance.status.get("complete", False),
+            ):
+                vmi = VirtualMachineInstance(
+                    name=vm.name,
+                    namespace=vm.namespace,
+                    client=admin_client,
+                )
+                assert not vmi.exists, (
+                    f"VMI {vm.name} should not exist during restore with RerunOnFailure strategy"
+                )
+                if sample:
+                    break
+
+    @pytest.mark.jira("CNV-63819")
+    @pytest.mark.parametrize(
+        "vm_for_snapshot_with_run_strategy",
+        [
+            pytest.param(
+                {
+                    "vm_name": "vm-cnv-63819-start-after",
+                    "run_strategy": VirtualMachine.RunStrategy.RERUNONFAILURE,
+                },
+            ),
+        ],
+        indirect=True,
+    )
+    def test_vm_starts_after_restore(
+        self,
+        admin_client,
+        vm_for_snapshot_with_run_strategy,
+        vm_snapshot_ready,
+    ):
+        """
+        Test that VM can be manually started after snapshot restore completes.
+
+        Steps:
+            1. Create VirtualMachineRestore and wait for completion
+            2. Start the VM manually
+            3. Wait for VM to reach Running state
+
+        Expected:
+            - VM is "Running" and SSH accessible
+        """
+        vm = vm_for_snapshot_with_run_strategy
+        LOGGER.info(f"Restoring VM {vm.name} then verifying it can be started")
+        with VirtualMachineRestore(
+            client=admin_client,
+            name=f"restore-{vm.name}",
+            namespace=vm.namespace,
+            vm_name=vm.name,
+            snapshot_name=vm_snapshot_ready.name,
+        ) as vm_restore:
+            vm_restore.wait_restore_done()
+            running_vm(vm=vm)
+            assert vm.ready, f"VM {vm.name} is not Ready after restore and start"
+
+
+class TestSnapshotRestoreRunStrategyRegression:
+    """
+    Regression tests for snapshot restore across different run strategies.
+
+    Validates that the fix for CNV-63819 does not break snapshot restore
+    for other run strategies.
+    """
+
+    @pytest.mark.jira("CNV-63819")
+    @pytest.mark.parametrize(
+        "vm_for_snapshot_with_run_strategy",
+        [
+            pytest.param(
+                {
+                    "vm_name": "vm-restore-always",
+                    "run_strategy": VirtualMachine.RunStrategy.ALWAYS,
+                },
+                id="always",
+            ),
+            pytest.param(
+                {
+                    "vm_name": "vm-restore-manual",
+                    "run_strategy": VirtualMachine.RunStrategy.MANUAL,
+                },
+                id="manual",
+            ),
+            pytest.param(
+                {
+                    "vm_name": "vm-restore-halted",
+                    "run_strategy": VirtualMachine.RunStrategy.HALTED,
+                },
+                id="halted",
+            ),
+        ],
+        indirect=True,
+    )
+    def test_snapshot_restore_completes(
+        self,
+        admin_client,
+        vm_for_snapshot_with_run_strategy,
+        vm_snapshot_ready,
+    ):
+        """
+        Test that snapshot restore completes for VM with the given run strategy.
+
+        Steps:
+            1. Create VirtualMachineRestore from the snapshot
+            2. Wait for restore to reach terminal state
+
+        Expected:
+            - VirtualMachineRestore status is "Complete"
+        """
+        vm = vm_for_snapshot_with_run_strategy
+        LOGGER.info(f"Restoring VM {vm.name} with run strategy regression test")
+        with VirtualMachineRestore(
+            client=admin_client,
+            name=f"restore-{vm.name}",
+            namespace=vm.namespace,
+            vm_name=vm.name,
+            snapshot_name=vm_snapshot_ready.name,
+        ) as vm_restore:
+            vm_restore.wait_restore_done()
+            assert vm_restore.instance.status.get("complete"), (
+                f"VirtualMachineRestore {vm_restore.name} did not reach Complete status"
+            )
+
+    @pytest.mark.jira("CNV-63819")
+    @pytest.mark.parametrize(
+        "vm_for_snapshot_with_run_strategy",
+        [
+            pytest.param(
+                {
+                    "vm_name": "vm-start-always",
+                    "run_strategy": VirtualMachine.RunStrategy.ALWAYS,
+                },
+                id="always",
+            ),
+            pytest.param(
+                {
+                    "vm_name": "vm-start-manual",
+                    "run_strategy": VirtualMachine.RunStrategy.MANUAL,
+                },
+                id="manual",
+            ),
+            pytest.param(
+                {
+                    "vm_name": "vm-start-halted",
+                    "run_strategy": VirtualMachine.RunStrategy.HALTED,
+                },
+                id="halted",
+            ),
+        ],
+        indirect=True,
+    )
+    def test_vm_starts_after_restore(
+        self,
+        admin_client,
+        vm_for_snapshot_with_run_strategy,
+        vm_snapshot_ready,
+    ):
+        """
+        Test that VM can be started after snapshot restore with the given run strategy.
+
+        Steps:
+            1. Create VirtualMachineRestore and wait for completion
+            2. Start the VM
+            3. Wait for VM to reach Running state
+
+        Expected:
+            - VM is "Running" and SSH accessible
+        """
+        vm = vm_for_snapshot_with_run_strategy
+        LOGGER.info(f"Restoring VM {vm.name} then starting it")
+        with VirtualMachineRestore(
+            client=admin_client,
+            name=f"restore-{vm.name}",
+            namespace=vm.namespace,
+            vm_name=vm.name,
+            snapshot_name=vm_snapshot_ready.name,
+        ) as vm_restore:
+            vm_restore.wait_restore_done()
+            running_vm(vm=vm)
+            assert vm.ready, f"VM {vm.name} is not Ready after restore and start"
+
+
+class TestSnapshotRestoreDataIntegrity:
+    """
+    End-to-end tests for snapshot restore data integrity with RerunOnFailure.
+
+    Validates that a restored VM has correct data state matching the snapshot point-in-time.
+    """
+
+    @pytest.mark.jira("CNV-63819")
+    @pytest.mark.parametrize(
+        "vm_for_snapshot_with_run_strategy",
+        [
+            pytest.param(
+                {
+                    "vm_name": "vm-data-pre-snap",
+                    "run_strategy": VirtualMachine.RunStrategy.RERUNONFAILURE,
+                },
+            ),
+        ],
+        indirect=True,
+    )
+    def test_preserves_pre_snapshot_data(self, restored_vm_with_data):
+        """
+        Test that files created before snapshot are preserved after restore.
+
+        Steps:
+            1. Read file original.txt from the restored VM
+
+        Expected:
+            - File content equals "data-before-snapshot"
+        """
+        LOGGER.info(f"Checking pre-snapshot data on restored VM {restored_vm_with_data.name}")
+        output = run_ssh_commands(
+            host=restored_vm_with_data.ssh_exec,
+            commands=shlex.split(f"bash -c {shlex.quote('cat original.txt')}"),
+        )[0].strip()
+        assert output == "data-before-snapshot", (
+            f"Expected 'data-before-snapshot' but got '{output}'"
+        )
+
+    @pytest.mark.jira("CNV-63819")
+    @pytest.mark.parametrize(
+        "vm_for_snapshot_with_run_strategy",
+        [
+            pytest.param(
+                {
+                    "vm_name": "vm-data-post-snap",
+                    "run_strategy": VirtualMachine.RunStrategy.RERUNONFAILURE,
+                },
+            ),
+        ],
+        indirect=True,
+    )
+    def test_removes_post_snapshot_data(self, restored_vm_with_data):
+        """
+        Test that files created after snapshot are removed after restore.
+
+        Steps:
+            1. Check if file after.txt exists on the restored VM
+
+        Expected:
+            - File after.txt does NOT exist
+        """
+        LOGGER.info(f"Checking post-snapshot data is absent on restored VM {restored_vm_with_data.name}")
+        output = run_ssh_commands(
+            host=restored_vm_with_data.ssh_exec,
+            commands=shlex.split(f"bash -c {shlex.quote('test -f after.txt && echo exists || echo missing')}"),
+        )[0].strip()
+        assert output == "missing", (
+            f"File after.txt should not exist after restore, but got '{output}'"
+        )
+
+
+@pytest.mark.jira("CNV-63819")
+@pytest.mark.parametrize(
+    "vm_for_snapshot_with_run_strategy",
+    [
+        pytest.param(
+            {
+                "vm_name": "vm-multi-restore",
+                "run_strategy": VirtualMachine.RunStrategy.RERUNONFAILURE,
+            },
+        ),
+    ],
+    indirect=True,
+)
+def test_multiple_snapshot_restores_complete(
+    admin_client,
+    vm_for_snapshot_with_run_strategy,
+    multiple_snapshots_for_restore,
+):
+    """
+    Test that multiple snapshots can be restored sequentially.
+
+    Steps:
+        1. Restore from first snapshot and wait for completion
+        2. Restore from third snapshot and wait for completion
+
+    Expected:
+        - Both VirtualMachineRestore operations reach "Complete" status
+    """
+    vm = vm_for_snapshot_with_run_strategy
+    snapshots_to_restore = [
+        multiple_snapshots_for_restore[0],
+        multiple_snapshots_for_restore[2],
+    ]
+    for idx, snapshot in enumerate(snapshots_to_restore):
+        restore_name = f"restore-{vm.name}-{idx}"
+        LOGGER.info(f"Restoring VM {vm.name} from snapshot {snapshot.name} (restore {idx + 1})")
+        with VirtualMachineRestore(
+            client=admin_client,
+            name=restore_name,
+            namespace=vm.namespace,
+            vm_name=vm.name,
+            snapshot_name=snapshot.name,
+        ) as vm_restore:
+            vm_restore.wait_restore_done()
+            assert vm_restore.instance.status.get("complete"), (
+                f"VirtualMachineRestore {restore_name} did not reach Complete status"
+            )
