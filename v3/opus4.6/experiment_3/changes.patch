diff --git a/tests/virt/node/general/test_vmi_reset.py b/tests/virt/node/general/test_vmi_reset.py
index a8a3656..0bd06e4 100644
--- a/tests/virt/node/general/test_vmi_reset.py
+++ b/tests/virt/node/general/test_vmi_reset.py
@@ -1,41 +1,356 @@
+"""
+Force/Hard VM Reset Tests
+
+STP Reference: ../stps/3.md
+Jira: https://issues.redhat.com/browse/VIRTSTRAT-357
+
+This module contains tests for the VMI reset subresource API,
+virtctl reset command, and associated error handling. The reset
+operation simulates a hardware reset button press, rebooting the
+guest OS without requiring pod rescheduling.
+"""
+
 import logging
 import shlex
 
 import pytest
+from kubernetes.client.rest import ApiException
+from ocp_resources.cluster_role import ClusterRole
+from ocp_resources.role_binding import RoleBinding
+from ocp_resources.virtual_machine_instance import VirtualMachineInstance
 from pyhelper_utils.shell import run_ssh_commands
 
-from utilities.virt import wait_for_running_vm
+from utilities.constants import UNPRIVILEGED_USER
+from utilities.infra import run_virtctl_command
+from utilities.virt import (
+    VirtualMachineForTests,
+    fedora_vm_body,
+    running_vm,
+    wait_for_running_vm,
+)
 
 LOGGER = logging.getLogger(__name__)
 
 
-def get_vm_boot_count(vm):
+def get_vm_boot_count(vm: VirtualMachineForTests) -> int:
+    """Get the number of boots recorded by systemd journal.
+
+    Args:
+        vm: Virtual machine to query.
+
+    Returns:
+        Number of boot entries in the journal.
+    """
     reboot_count = run_ssh_commands(
         host=vm.ssh_exec,
         commands=[shlex.split("journalctl --list-boots | wc -l")],
     )[0].strip()
-
     return int(reboot_count)
 
 
+def get_vm_boot_time(vm: VirtualMachineForTests) -> str:
+    """Get the system boot time from the guest OS.
+
+    Args:
+        vm: Virtual machine to query.
+
+    Returns:
+        Boot time string from uptime -s.
+    """
+    boot_time = run_ssh_commands(
+        host=vm.ssh_exec,
+        commands=[shlex.split("uptime -s")],
+    )[0].strip()
+    return boot_time
+
+
+# --- Fixtures for TestVMIReset (API reset) ---
+
+
 @pytest.fixture(scope="class")
 def boot_count_before_reset(vm_for_test):
     return get_vm_boot_count(vm=vm_for_test)
 
 
 @pytest.fixture(scope="class")
-def vm_reset_and_running(vm_for_test):
+def vmi_uid_before_reset(vm_for_test):
+    return vm_for_test.vmi.instance.metadata.uid
+
+
+@pytest.fixture(scope="class")
+def boot_time_before_reset(vm_for_test):
+    return get_vm_boot_time(vm=vm_for_test)
+
+
+@pytest.fixture(scope="class")
+def vm_reset_and_running(
+    vm_for_test,
+    boot_count_before_reset,
+    vmi_uid_before_reset,
+    boot_time_before_reset,
+):
+    LOGGER.info(f"Performing VMI reset via API on {vm_for_test.name}")
     vm_for_test.vmi.reset()
     wait_for_running_vm(vm=vm_for_test)
 
 
-@pytest.mark.parametrize("vm_for_test", [pytest.param("vm-for-reset-test")], indirect=True)
+# --- Fixtures for TestVMIResetVirtctl ---
+
+
+@pytest.fixture(scope="class")
+def vm_virtctl_reset_result(vm_for_test):
+    LOGGER.info(f"Performing virtctl reset on {vm_for_test.name}")
+    result, output, err = run_virtctl_command(
+        command=["reset", vm_for_test.name],
+        namespace=vm_for_test.namespace,
+        verify_stderr=False,
+    )
+    wait_for_running_vm(vm=vm_for_test)
+    return result, output, err
+
+
+# --- Fixtures for TestVMIResetNegative ---
+
+
+@pytest.fixture()
+def stopped_vm(unprivileged_client, namespace):
+    name = "vm-for-reset-stopped"
+    with VirtualMachineForTests(
+        client=unprivileged_client,
+        name=name,
+        namespace=namespace.name,
+        body=fedora_vm_body(name=name),
+    ) as vm:
+        yield vm
+
+
+@pytest.fixture()
+def paused_vm(unprivileged_client, namespace):
+    name = "vm-for-reset-paused"
+    with VirtualMachineForTests(
+        client=unprivileged_client,
+        name=name,
+        namespace=namespace.name,
+        body=fedora_vm_body(name=name),
+    ) as vm:
+        running_vm(vm=vm)
+        LOGGER.info(f"Pausing VM {vm.name}")
+        vm.vmi.pause(wait=True)
+        yield vm
+
+
+# --- Fixtures for TestVMIResetRBAC ---
+
+
+@pytest.fixture(scope="session")
+def kubevirt_edit_cluster_role(admin_client):
+    return ClusterRole(
+        name="kubevirt.io:edit",
+        client=admin_client,
+        ensure_exists=True,
+    )
+
+
+@pytest.fixture()
+def unprivileged_user_edit_rolebinding(admin_client, namespace, kubevirt_edit_cluster_role):
+    with RoleBinding(
+        name="role-bind-kubevirt-edit-reset",
+        namespace=namespace.name,
+        client=admin_client,
+        subjects_kind="User",
+        subjects_name=UNPRIVILEGED_USER,
+        subjects_namespace=namespace.name,
+        role_ref_kind=kubevirt_edit_cluster_role.kind,
+        role_ref_name=kubevirt_edit_cluster_role.name,
+    ) as role_binding:
+        yield role_binding
+
+
+# === Test Classes ===
+
+
+@pytest.mark.parametrize(
+    "vm_for_test",
+    [pytest.param("vm-for-reset-api-test")],
+    indirect=True,
+)
 class TestVMIReset:
+    """Tests for core VMI reset functionality via subresource API."""
+
     @pytest.mark.polarion("CNV-12373")
-    def test_reset_success(
+    def test_reset_running_vmi_via_api(
         self,
         vm_for_test,
         boot_count_before_reset,
         vm_reset_and_running,
     ):
-        assert get_vm_boot_count(vm=vm_for_test) - boot_count_before_reset == 1, "Expected 1 boot entry after VMI reset"
+        """Test that a running VMI can be reset via the subresource API
+        and the guest reboots successfully.
+
+        Steps:
+            1. Record boot count before reset
+            2. Call the VMI reset subresource API endpoint
+            3. Wait for the VM to return to Running state
+            4. Read the boot count from the guest
+
+        Expected:
+            - Boot count increased by 1 compared to pre-reset value
+        """
+        assert get_vm_boot_count(vm=vm_for_test) - boot_count_before_reset == 1, (
+            "Expected 1 boot entry after VMI reset"
+        )
+
+    def test_vmi_uid_unchanged_after_reset(
+        self,
+        vm_for_test,
+        vmi_uid_before_reset,
+        vm_reset_and_running,
+    ):
+        """Test that the VMI UID remains the same after a reset,
+        confirming no pod rescheduling occurred.
+
+        Steps:
+            1. Record VMI UID before reset
+            2. Perform VMI reset via API
+            3. Wait for VM to return to Running state
+            4. Read VMI UID after reset
+
+        Expected:
+            - VMI UID after reset equals VMI UID before reset
+        """
+        vmi_uid_after_reset = vm_for_test.vmi.instance.metadata.uid
+        assert vmi_uid_after_reset == vmi_uid_before_reset, (
+            f"VMI UID changed after reset: expected {vmi_uid_before_reset}, "
+            f"got {vmi_uid_after_reset}"
+        )
+
+    def test_boot_time_changes_after_reset(
+        self,
+        vm_for_test,
+        boot_time_before_reset,
+        vm_reset_and_running,
+    ):
+        """Test that the guest system boot time changes after a reset,
+        confirming the guest OS actually rebooted.
+
+        Steps:
+            1. Read system boot time from the guest before reset
+            2. Perform VMI reset via API
+            3. Wait for VM to return to Running state
+            4. Read system boot time from the guest after reset
+
+        Expected:
+            - Boot time after reset is more recent than boot time before reset
+        """
+        boot_time_after_reset = get_vm_boot_time(vm=vm_for_test)
+        assert boot_time_after_reset != boot_time_before_reset, (
+            f"Boot time did not change after reset: {boot_time_before_reset}"
+        )
+
+
+@pytest.mark.parametrize(
+    "vm_for_test",
+    [pytest.param("vm-for-virtctl-reset-test")],
+    indirect=True,
+)
+class TestVMIResetVirtctl:
+    """Tests for VMI reset via virtctl command."""
+
+    def test_reset_running_vmi_via_virtctl(
+        self,
+        vm_for_test,
+        vm_virtctl_reset_result,
+    ):
+        """Test that a running VMI can be reset using the virtctl reset command.
+
+        Steps:
+            1. Execute `virtctl reset <vmi-name>` command
+            2. Wait for the VM to return to Running state
+
+        Expected:
+            - virtctl command exits with return code 0
+        """
+        result, _output, err = vm_virtctl_reset_result
+        assert result, f"virtctl reset command failed: {err}"
+
+
+class TestVMIResetNegative:
+    """Tests for VMI reset error handling and edge cases."""
+
+    def test_reset_fails_on_stopped_vmi(self, stopped_vm):
+        """[NEGATIVE] Test that resetting a stopped VMI returns a Not Found error.
+
+        Steps:
+            1. Create a VM in Halted state (no VMI exists)
+            2. Attempt to call the VMI reset subresource API
+
+        Expected:
+            - API returns a 404 Not Found error
+        """
+        LOGGER.info(f"Attempting reset on stopped VM {stopped_vm.name}")
+        with pytest.raises(ApiException, match="404"):
+            stopped_vm.vmi.reset()
+
+    def test_reset_fails_on_nonexistent_vmi(self, admin_client, namespace):
+        """[NEGATIVE] Test that resetting a non-existent VMI returns a Not Found error.
+
+        Steps:
+            1. Attempt to call the VMI reset subresource API with a non-existent VMI name
+
+        Expected:
+            - API returns a 404 Not Found error
+        """
+        nonexistent_vmi = VirtualMachineInstance(
+            name="nonexistent-vmi-for-reset",
+            namespace=namespace.name,
+            client=admin_client,
+        )
+        LOGGER.info("Attempting reset on non-existent VMI")
+        with pytest.raises(ApiException, match="404"):
+            nonexistent_vmi.reset()
+
+    def test_reset_succeeds_on_paused_vmi(self, paused_vm):
+        """Test that resetting a paused VMI succeeds without raising an error.
+
+        Steps:
+            1. Create and start a VM, then pause it
+            2. Call the VMI reset subresource API on the paused VMI
+
+        Expected:
+            - Reset operation succeeds without raising an exception
+        """
+        LOGGER.info(f"Performing reset on paused VM {paused_vm.name}")
+        paused_vm.vmi.reset()
+
+
+@pytest.mark.parametrize(
+    "vm_for_test",
+    [pytest.param("vm-for-rbac-reset-test")],
+    indirect=True,
+)
+class TestVMIResetRBAC:
+    """Tests for RBAC enforcement on VMI reset operations."""
+
+    @pytest.mark.usefixtures("unprivileged_user_edit_rolebinding")
+    def test_user_with_edit_role_can_reset_vmi(
+        self,
+        vm_for_test,
+        unprivileged_client,
+    ):
+        """Test that a user with the edit ClusterRole can perform a VMI reset.
+
+        Steps:
+            1. Bind kubevirt.io:edit ClusterRole to unprivileged user
+            2. As the unprivileged user, call the VMI reset subresource API
+
+        Expected:
+            - Reset operation succeeds without authorization error
+        """
+        unprivileged_vmi = VirtualMachineInstance(
+            name=vm_for_test.vmi.name,
+            namespace=vm_for_test.namespace,
+            client=unprivileged_client,
+        )
+        LOGGER.info(f"Attempting reset as unprivileged user on {vm_for_test.name}")
+        unprivileged_vmi.reset()
+        wait_for_running_vm(vm=vm_for_test)
