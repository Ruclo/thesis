diff --git a/tests/virt/node/video_config/__init__.py b/tests/virt/node/video_config/__init__.py
new file mode 100644
index 0000000..fd06fba
--- /dev/null
+++ b/tests/virt/node/video_config/__init__.py
@@ -0,0 +1 @@
+"""VideoConfig feature tests."""
diff --git a/tests/virt/node/video_config/conftest.py b/tests/virt/node/video_config/conftest.py
new file mode 100644
index 0000000..31bcbd8
--- /dev/null
+++ b/tests/virt/node/video_config/conftest.py
@@ -0,0 +1,53 @@
+"""
+Fixtures for VideoConfig feature tests.
+"""
+
+import pytest
+
+from utilities.virt import VirtualMachineForTestsFromTemplate, running_vm, vm_instance_from_template
+
+
+@pytest.fixture()
+def video_config_vm(
+    request,
+    unprivileged_client,
+    namespace,
+    golden_image_data_volume_template_for_test_scope_class,
+):
+    """
+    Fixture to create a VM with custom video configuration.
+
+    Yields:
+        VirtualMachineForTestsFromTemplate: VM instance with configured video device
+    """
+    with vm_instance_from_template(
+        request=request,
+        unprivileged_client=unprivileged_client,
+        namespace=namespace,
+        data_volume_template=golden_image_data_volume_template_for_test_scope_class,
+    ) as vm:
+        running_vm(vm=vm, wait_for_interfaces=False, check_ssh_connectivity=False)
+        yield vm
+
+
+@pytest.fixture()
+def video_config_vm_for_migration(
+    request,
+    unprivileged_client,
+    namespace,
+    golden_image_data_volume_template_for_test_scope_function,
+):
+    """
+    Fixture to create a VM for migration tests.
+
+    Yields:
+        VirtualMachineForTestsFromTemplate: VM instance with configured video device
+    """
+    with vm_instance_from_template(
+        request=request,
+        unprivileged_client=unprivileged_client,
+        namespace=namespace,
+        data_volume_template=golden_image_data_volume_template_for_test_scope_function,
+    ) as vm:
+        running_vm(vm=vm, wait_for_interfaces=False, check_ssh_connectivity=False)
+        yield vm
diff --git a/tests/virt/node/video_config/test_video_config.py b/tests/virt/node/video_config/test_video_config.py
new file mode 100644
index 0000000..fca2db7
--- /dev/null
+++ b/tests/virt/node/video_config/test_video_config.py
@@ -0,0 +1,948 @@
+"""
+Tests for VideoConfig feature gate.
+
+This module tests the ability for VM owners to explicitly set the video device type.
+Feature allows configuration of video.type field in VM spec with support for:
+- virtio, vga, bochs, cirrus, ramfb (architecture-dependent)
+
+Test Coverage:
+- VideoConfig feature gate enabled by default
+- VM creation with different video device types
+- Domain XML verification
+- Architecture-specific validation
+- HCO feature gate propagation
+- Backward compatibility
+- EFI/BIOS boot configurations
+- Video type persistence across VM restart and migration
+"""
+
+import logging
+
+import pytest
+from ocp_resources.kubevirt import KubeVirt
+from ocp_resources.virtual_machine import VirtualMachine
+
+from tests.install_upgrade_operators.constants import FG_ENABLED
+from tests.os_params import RHEL_LATEST, RHEL_LATEST_LABELS, WINDOWS_LATEST, WINDOWS_LATEST_LABELS
+from utilities.constants import FEATURE_GATES, TIMEOUT_5MIN
+from utilities.hco import ResourceEditorValidateHCOReconcile
+from utilities.virt import (
+    VirtualMachineForTestsFromTemplate,
+    migrate_vm_and_verify,
+    running_vm,
+)
+
+LOGGER = logging.getLogger(__name__)
+
+# Video device type constants
+VIDEO_TYPE_VIRTIO = "virtio"
+VIDEO_TYPE_VGA = "vga"
+VIDEO_TYPE_BOCHS = "bochs"
+VIDEO_TYPE_CIRRUS = "cirrus"
+VIDEO_TYPE_RAMFB = "ramfb"
+
+# Feature gate constant
+VIDEO_CONFIG_FG = "videoConfig"
+VIDEO_CONFIG_FG_KUBEVIRT = "VideoConfig"
+
+
+def get_video_model_from_domain_xml(vm: VirtualMachineForTestsFromTemplate) -> str:
+    """
+    Extract video model type from VM domain XML.
+
+    Args:
+        vm: VirtualMachineForTestsFromTemplate instance
+
+    Returns:
+        str: Video model type (e.g., 'vga', 'virtio', 'bochs')
+    """
+    video_devices = vm.privileged_vmi.xml_dict["domain"]["devices"]["video"]
+    # video can be a list or a single dict depending on configuration
+    if isinstance(video_devices, list):
+        return video_devices[0]["model"]["@type"]
+    return video_devices["model"]["@type"]
+
+
+def create_vm_spec_with_video_type(video_type: str | None = None) -> dict:
+    """
+    Create VM spec dict with specified video device type.
+
+    Args:
+        video_type: Video device type (virtio, vga, bochs, cirrus, ramfb) or None for default
+
+    Returns:
+        dict: VM spec with video configuration
+    """
+    if video_type is None:
+        return {}
+
+    return {
+        "spec": {
+            "template": {
+                "spec": {
+                    "domain": {
+                        "devices": {
+                            "video": {
+                                "type": video_type,
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+
+@pytest.mark.gating
+def test_videoconfig_feature_gate_enabled_by_default(kubevirt_feature_gates):
+    """
+    Verify VideoConfig feature gate is enabled by default in KubeVirt.
+
+    Polarion:
+        assignee: agupta
+        casecomponent: virt
+        caseimportance: critical
+        initialEstimate: 1/6h
+        testSteps:
+            1. Check KubeVirt feature gates list
+        expectedResults:
+            1. VideoConfig feature gate is present in enabled feature gates
+    """
+    assert VIDEO_CONFIG_FG_KUBEVIRT in kubevirt_feature_gates, (
+        f"VideoConfig feature gate not enabled by default. Enabled gates: {kubevirt_feature_gates}"
+    )
+
+
+@pytest.mark.gating
+def test_hco_videoconfig_default_value(hco_spec):
+    """
+    Verify HCO CR has videoConfig set to true by default.
+
+    Polarion:
+        assignee: agupta
+        casecomponent: virt
+        caseimportance: critical
+        initialEstimate: 1/6h
+        testSteps:
+            1. Get HCO spec
+            2. Check featureGates.videoConfig value
+        expectedResults:
+            1. HCO spec retrieved successfully
+            2. videoConfig is set to true
+    """
+    feature_gates = hco_spec.get(FEATURE_GATES, {})
+    assert feature_gates.get(VIDEO_CONFIG_FG) == FG_ENABLED, (
+        f"HCO videoConfig feature gate not enabled by default. "
+        f"Value: {feature_gates.get(VIDEO_CONFIG_FG)}, Expected: {FG_ENABLED}"
+    )
+
+
+@pytest.mark.gating
+def test_hco_videoconfig_propagates_to_kubevirt(
+    hyperconverged_resource_scope_function,
+    kubevirt_resource_scope_session,
+    kubevirt_feature_gates,
+):
+    """
+    Verify HCO propagates videoConfig feature gate setting to KubeVirt CR.
+
+    Polarion:
+        assignee: agupta
+        casecomponent: virt
+        caseimportance: critical
+        initialEstimate: 1/4h
+        testSteps:
+            1. Verify VideoConfig is enabled in KubeVirt when HCO has it enabled
+            2. Disable videoConfig in HCO
+            3. Wait for KubeVirt reconciliation
+            4. Verify VideoConfig is disabled in KubeVirt
+            5. Re-enable videoConfig in HCO
+            6. Verify VideoConfig is enabled in KubeVirt again
+        expectedResults:
+            1. VideoConfig present in KubeVirt feature gates initially
+            2. HCO updated successfully
+            3. KubeVirt reconciled
+            4. VideoConfig removed from KubeVirt feature gates
+            5. HCO updated successfully
+            6. VideoConfig present in KubeVirt feature gates
+    """
+    # Initial state - should be enabled
+    assert VIDEO_CONFIG_FG_KUBEVIRT in kubevirt_feature_gates, "VideoConfig not initially enabled in KubeVirt"
+
+    # Disable videoConfig in HCO
+    with ResourceEditorValidateHCOReconcile(
+        patches={
+            hyperconverged_resource_scope_function: {
+                "spec": {FEATURE_GATES: {VIDEO_CONFIG_FG: not FG_ENABLED}}
+            }
+        },
+        list_resource_reconcile=[KubeVirt],
+        wait_for_reconcile_post_update=True,
+    ):
+        # Verify VideoConfig is disabled in KubeVirt
+        kubevirt_resource_scope_session.wait_for_resource(
+            timeout=TIMEOUT_5MIN,
+        )
+        current_feature_gates = (
+            kubevirt_resource_scope_session.instance.spec.get("configuration", {})
+            .get("developerConfiguration", {})
+            .get("featureGates", [])
+        )
+        assert VIDEO_CONFIG_FG_KUBEVIRT not in current_feature_gates, (
+            f"VideoConfig still present in KubeVirt after disabling in HCO. Gates: {current_feature_gates}"
+        )
+
+    # After context exit, HCO is restored and KubeVirt should have VideoConfig enabled again
+    kubevirt_resource_scope_session.wait_for_resource(timeout=TIMEOUT_5MIN)
+    restored_feature_gates = (
+        kubevirt_resource_scope_session.instance.spec.get("configuration", {})
+        .get("developerConfiguration", {})
+        .get("featureGates", [])
+    )
+    assert VIDEO_CONFIG_FG_KUBEVIRT in restored_feature_gates, (
+        f"VideoConfig not restored in KubeVirt after re-enabling in HCO. Gates: {restored_feature_gates}"
+    )
+
+
+@pytest.mark.gating
+@pytest.mark.parametrize(
+    "golden_image_data_source_for_test_scope_class",
+    [pytest.param({"os_dict": RHEL_LATEST})],
+    indirect=True,
+)
+class TestVideoConfigBasicFunctionality:
+    """Test basic VideoConfig functionality with different video device types."""
+
+    @pytest.mark.polarion("CNV-11301")
+    @pytest.mark.parametrize(
+        "video_config_vm, expected_video_type",
+        [
+            pytest.param(
+                {
+                    "vm_name": "rhel-vm-video-virtio",
+                    "template_labels": RHEL_LATEST_LABELS,
+                    "vm_dict": create_vm_spec_with_video_type(VIDEO_TYPE_VIRTIO),
+                },
+                VIDEO_TYPE_VIRTIO,
+                id="test_video_type_virtio",
+            ),
+        ],
+        indirect=["video_config_vm"],
+    )
+    def test_vm_with_virtio_video_type(self, video_config_vm, expected_video_type):
+        """
+        Test VM creation with virtio video device type.
+
+        Polarion:
+            assignee: agupta
+            casecomponent: virt
+            caseimportance: critical
+            initialEstimate: 1/4h
+            testSteps:
+                1. Create VM with video.type=virtio
+                2. Start VM
+                3. Verify domain XML has virtio video model
+            expectedResults:
+                1. VM created successfully
+                2. VM started successfully
+                3. Domain XML shows model type="virtio"
+        """
+        actual_video_type = get_video_model_from_domain_xml(vm=video_config_vm)
+        assert actual_video_type == expected_video_type, (
+            f"Video type mismatch. Expected: {expected_video_type}, Actual: {actual_video_type}"
+        )
+
+    @pytest.mark.polarion("CNV-11302")
+    @pytest.mark.parametrize(
+        "video_config_vm, expected_video_type",
+        [
+            pytest.param(
+                {
+                    "vm_name": "rhel-vm-video-vga",
+                    "template_labels": RHEL_LATEST_LABELS,
+                    "vm_dict": create_vm_spec_with_video_type(VIDEO_TYPE_VGA),
+                },
+                VIDEO_TYPE_VGA,
+                id="test_video_type_vga",
+            ),
+        ],
+        indirect=["video_config_vm"],
+    )
+    def test_vm_with_vga_video_type(self, video_config_vm, expected_video_type):
+        """
+        Test VM creation with VGA video device type.
+
+        Polarion:
+            assignee: agupta
+            casecomponent: virt
+            caseimportance: critical
+            initialEstimate: 1/4h
+            testSteps:
+                1. Create VM with video.type=vga
+                2. Start VM
+                3. Verify domain XML has vga video model
+            expectedResults:
+                1. VM created successfully
+                2. VM started successfully
+                3. Domain XML shows model type="vga"
+        """
+        actual_video_type = get_video_model_from_domain_xml(vm=video_config_vm)
+        assert actual_video_type == expected_video_type, (
+            f"Video type mismatch. Expected: {expected_video_type}, Actual: {actual_video_type}"
+        )
+
+    @pytest.mark.polarion("CNV-11303")
+    @pytest.mark.parametrize(
+        "video_config_vm, expected_video_type",
+        [
+            pytest.param(
+                {
+                    "vm_name": "rhel-vm-video-bochs",
+                    "template_labels": RHEL_LATEST_LABELS,
+                    "vm_dict": create_vm_spec_with_video_type(VIDEO_TYPE_BOCHS),
+                },
+                VIDEO_TYPE_BOCHS,
+                id="test_video_type_bochs",
+            ),
+        ],
+        indirect=["video_config_vm"],
+    )
+    def test_vm_with_bochs_video_type(self, video_config_vm, expected_video_type):
+        """
+        Test VM creation with bochs video device type.
+
+        Polarion:
+            assignee: agupta
+            casecomponent: virt
+            caseimportance: critical
+            initialEstimate: 1/4h
+            testSteps:
+                1. Create VM with video.type=bochs
+                2. Start VM
+                3. Verify domain XML has bochs video model
+            expectedResults:
+                1. VM created successfully
+                2. VM started successfully
+                3. Domain XML shows model type="bochs"
+        """
+        actual_video_type = get_video_model_from_domain_xml(vm=video_config_vm)
+        assert actual_video_type == expected_video_type, (
+            f"Video type mismatch. Expected: {expected_video_type}, Actual: {actual_video_type}"
+        )
+
+    @pytest.mark.polarion("CNV-11304")
+    @pytest.mark.parametrize(
+        "video_config_vm, expected_video_type",
+        [
+            pytest.param(
+                {
+                    "vm_name": "rhel-vm-video-cirrus",
+                    "template_labels": RHEL_LATEST_LABELS,
+                    "vm_dict": create_vm_spec_with_video_type(VIDEO_TYPE_CIRRUS),
+                },
+                VIDEO_TYPE_CIRRUS,
+                id="test_video_type_cirrus",
+            ),
+        ],
+        indirect=["video_config_vm"],
+    )
+    def test_vm_with_cirrus_video_type(self, video_config_vm, expected_video_type):
+        """
+        Test VM creation with cirrus video device type.
+
+        Polarion:
+            assignee: agupta
+            casecomponent: virt
+            caseimportance: high
+            initialEstimate: 1/4h
+            testSteps:
+                1. Create VM with video.type=cirrus
+                2. Start VM
+                3. Verify domain XML has cirrus video model
+            expectedResults:
+                1. VM created successfully
+                2. VM started successfully
+                3. Domain XML shows model type="cirrus"
+        """
+        actual_video_type = get_video_model_from_domain_xml(vm=video_config_vm)
+        assert actual_video_type == expected_video_type, (
+            f"Video type mismatch. Expected: {expected_video_type}, Actual: {actual_video_type}"
+        )
+
+    @pytest.mark.polarion("CNV-11305")
+    @pytest.mark.parametrize(
+        "video_config_vm, expected_video_type",
+        [
+            pytest.param(
+                {
+                    "vm_name": "rhel-vm-video-ramfb",
+                    "template_labels": RHEL_LATEST_LABELS,
+                    "vm_dict": create_vm_spec_with_video_type(VIDEO_TYPE_RAMFB),
+                },
+                VIDEO_TYPE_RAMFB,
+                id="test_video_type_ramfb",
+            ),
+        ],
+        indirect=["video_config_vm"],
+    )
+    def test_vm_with_ramfb_video_type(self, video_config_vm, expected_video_type):
+        """
+        Test VM creation with ramfb video device type.
+
+        Polarion:
+            assignee: agupta
+            casecomponent: virt
+            caseimportance: high
+            initialEstimate: 1/4h
+            testSteps:
+                1. Create VM with video.type=ramfb
+                2. Start VM
+                3. Verify domain XML has ramfb video model
+            expectedResults:
+                1. VM created successfully
+                2. VM started successfully
+                3. Domain XML shows model type="ramfb"
+        """
+        actual_video_type = get_video_model_from_domain_xml(vm=video_config_vm)
+        assert actual_video_type == expected_video_type, (
+            f"Video type mismatch. Expected: {expected_video_type}, Actual: {actual_video_type}"
+        )
+
+    @pytest.mark.polarion("CNV-11306")
+    @pytest.mark.parametrize(
+        "video_config_vm",
+        [
+            pytest.param(
+                {
+                    "vm_name": "rhel-vm-no-video-config",
+                    "template_labels": RHEL_LATEST_LABELS,
+                    "vm_dict": create_vm_spec_with_video_type(None),
+                },
+                id="test_vm_without_video_type_uses_default",
+            ),
+        ],
+        indirect=["video_config_vm"],
+    )
+    def test_vm_without_video_type_uses_default(self, video_config_vm):
+        """
+        Test VM without video.type field uses architecture default.
+
+        Polarion:
+            assignee: agupta
+            casecomponent: virt
+            caseimportance: high
+            initialEstimate: 1/4h
+            testSteps:
+                1. Create VM without video.type field
+                2. Start VM
+                3. Verify domain XML has default video model (vga for BIOS, bochs for EFI)
+            expectedResults:
+                1. VM created successfully
+                2. VM started successfully
+                3. Domain XML shows default video model type
+        """
+        actual_video_type = get_video_model_from_domain_xml(vm=video_config_vm)
+        # Default for x86_64 BIOS is vga, for EFI is bochs
+        # Since we're not specifying firmware, it depends on the template default
+        assert actual_video_type in [VIDEO_TYPE_VGA, VIDEO_TYPE_BOCHS], (
+            f"Unexpected default video type: {actual_video_type}. Expected vga or bochs"
+        )
+
+
+@pytest.mark.parametrize(
+    "golden_image_data_source_for_test_scope_class",
+    [pytest.param({"os_dict": RHEL_LATEST})],
+    indirect=True,
+)
+class TestVideoConfigEFIBIOS:
+    """Test VideoConfig with different firmware configurations (EFI/BIOS)."""
+
+    @pytest.mark.polarion("CNV-11307")
+    @pytest.mark.parametrize(
+        "video_config_vm, expected_video_type",
+        [
+            pytest.param(
+                {
+                    "vm_name": "rhel-vm-efi-bochs",
+                    "template_labels": RHEL_LATEST_LABELS,
+                    "vm_dict": {
+                        "spec": {
+                            "template": {
+                                "spec": {
+                                    "domain": {
+                                        "firmware": {
+                                            "bootloader": {
+                                                "efi": {},
+                                            }
+                                        },
+                                        "devices": {
+                                            "video": {
+                                                "type": VIDEO_TYPE_BOCHS,
+                                            }
+                                        },
+                                    }
+                                }
+                            }
+                        }
+                    },
+                },
+                VIDEO_TYPE_BOCHS,
+                id="test_efi_with_bochs_video",
+            ),
+        ],
+        indirect=["video_config_vm"],
+    )
+    def test_efi_vm_with_bochs_video_type(self, video_config_vm, expected_video_type):
+        """
+        Test EFI VM with bochs video device type.
+
+        Polarion:
+            assignee: agupta
+            casecomponent: virt
+            caseimportance: high
+            initialEstimate: 1/4h
+            testSteps:
+                1. Create EFI VM with video.type=bochs
+                2. Start VM
+                3. Verify domain XML has bochs video model
+            expectedResults:
+                1. VM created successfully
+                2. VM started successfully
+                3. Domain XML shows model type="bochs"
+        """
+        actual_video_type = get_video_model_from_domain_xml(vm=video_config_vm)
+        assert actual_video_type == expected_video_type, (
+            f"Video type mismatch for EFI VM. Expected: {expected_video_type}, Actual: {actual_video_type}"
+        )
+
+    @pytest.mark.polarion("CNV-11308")
+    @pytest.mark.parametrize(
+        "video_config_vm, expected_video_type",
+        [
+            pytest.param(
+                {
+                    "vm_name": "rhel-vm-bios-vga",
+                    "template_labels": RHEL_LATEST_LABELS,
+                    "vm_dict": {
+                        "spec": {
+                            "template": {
+                                "spec": {
+                                    "domain": {
+                                        "firmware": {
+                                            "bootloader": {
+                                                "bios": {},
+                                            }
+                                        },
+                                        "devices": {
+                                            "video": {
+                                                "type": VIDEO_TYPE_VGA,
+                                            }
+                                        },
+                                    }
+                                }
+                            }
+                        }
+                    },
+                },
+                VIDEO_TYPE_VGA,
+                id="test_bios_with_vga_video",
+            ),
+        ],
+        indirect=["video_config_vm"],
+    )
+    def test_bios_vm_with_vga_video_type(self, video_config_vm, expected_video_type):
+        """
+        Test BIOS VM with VGA video device type.
+
+        Polarion:
+            assignee: agupta
+            casecomponent: virt
+            caseimportance: high
+            initialEstimate: 1/4h
+            testSteps:
+                1. Create BIOS VM with video.type=vga
+                2. Start VM
+                3. Verify domain XML has vga video model
+            expectedResults:
+                1. VM created successfully
+                2. VM started successfully
+                3. Domain XML shows model type="vga"
+        """
+        actual_video_type = get_video_model_from_domain_xml(vm=video_config_vm)
+        assert actual_video_type == expected_video_type, (
+            f"Video type mismatch for BIOS VM. Expected: {expected_video_type}, Actual: {actual_video_type}"
+        )
+
+
+@pytest.mark.parametrize(
+    "golden_image_data_source_for_test_scope_function",
+    [pytest.param({"os_dict": RHEL_LATEST})],
+    indirect=True,
+)
+class TestVideoConfigPersistence:
+    """Test video configuration persistence across VM operations."""
+
+    @pytest.mark.polarion("CNV-11309")
+    @pytest.mark.parametrize(
+        "video_config_vm_for_migration, expected_video_type",
+        [
+            pytest.param(
+                {
+                    "vm_name": "rhel-vm-restart-virtio",
+                    "template_labels": RHEL_LATEST_LABELS,
+                    "vm_dict": create_vm_spec_with_video_type(VIDEO_TYPE_VIRTIO),
+                },
+                VIDEO_TYPE_VIRTIO,
+                id="test_video_type_persistence_restart",
+            ),
+        ],
+        indirect=["video_config_vm_for_migration"],
+    )
+    def test_video_type_persists_across_vm_restart(
+        self,
+        video_config_vm_for_migration,
+        expected_video_type,
+    ):
+        """
+        Test video type persists across VM restart.
+
+        Polarion:
+            assignee: agupta
+            casecomponent: virt
+            caseimportance: high
+            initialEstimate: 1/4h
+            testSteps:
+                1. Create VM with video.type=virtio
+                2. Start VM and verify video type in domain XML
+                3. Stop VM
+                4. Start VM again
+                5. Verify video type is still virtio
+            expectedResults:
+                1. VM created successfully
+                2. Video type is virtio
+                3. VM stopped successfully
+                4. VM started successfully
+                5. Video type is still virtio
+        """
+        # Verify initial video type
+        initial_video_type = get_video_model_from_domain_xml(vm=video_config_vm_for_migration)
+        assert initial_video_type == expected_video_type, (
+            f"Initial video type mismatch. Expected: {expected_video_type}, Actual: {initial_video_type}"
+        )
+
+        # Stop and start VM
+        video_config_vm_for_migration.stop(wait=True)
+        video_config_vm_for_migration.start(wait=True)
+        running_vm(
+            vm=video_config_vm_for_migration,
+            wait_for_interfaces=False,
+            check_ssh_connectivity=False,
+        )
+
+        # Verify video type after restart
+        restarted_video_type = get_video_model_from_domain_xml(vm=video_config_vm_for_migration)
+        assert restarted_video_type == expected_video_type, (
+            f"Video type changed after restart. Expected: {expected_video_type}, Actual: {restarted_video_type}"
+        )
+
+    @pytest.mark.polarion("CNV-11310")
+    @pytest.mark.parametrize(
+        "video_config_vm_for_migration, expected_video_type",
+        [
+            pytest.param(
+                {
+                    "vm_name": "rhel-vm-migration-vga",
+                    "template_labels": RHEL_LATEST_LABELS,
+                    "vm_dict": create_vm_spec_with_video_type(VIDEO_TYPE_VGA),
+                },
+                VIDEO_TYPE_VGA,
+                id="test_video_type_persistence_migration",
+            ),
+        ],
+        indirect=["video_config_vm_for_migration"],
+    )
+    def test_video_type_persists_across_live_migration(
+        self,
+        skip_when_one_node,
+        skip_if_no_common_cpu,
+        video_config_vm_for_migration,
+        expected_video_type,
+    ):
+        """
+        Test video type persists across live migration.
+
+        Polarion:
+            assignee: agupta
+            casecomponent: virt
+            caseimportance: high
+            initialEstimate: 1/4h
+            testSteps:
+                1. Create VM with video.type=vga
+                2. Start VM and verify video type in domain XML
+                3. Live migrate VM to another node
+                4. Verify video type is still vga
+            expectedResults:
+                1. VM created successfully
+                2. Video type is vga
+                3. VM migrated successfully
+                4. Video type is still vga
+        """
+        # Verify initial video type
+        initial_video_type = get_video_model_from_domain_xml(vm=video_config_vm_for_migration)
+        assert initial_video_type == expected_video_type, (
+            f"Initial video type mismatch. Expected: {expected_video_type}, Actual: {initial_video_type}"
+        )
+
+        # Perform live migration
+        migrate_vm_and_verify(
+            vm=video_config_vm_for_migration,
+            check_ssh_connectivity=False,
+        )
+
+        # Verify video type after migration
+        migrated_video_type = get_video_model_from_domain_xml(vm=video_config_vm_for_migration)
+        assert migrated_video_type == expected_video_type, (
+            f"Video type changed after migration. Expected: {expected_video_type}, Actual: {migrated_video_type}"
+        )
+
+
+@pytest.mark.parametrize(
+    "golden_image_data_source_for_test_scope_class",
+    [pytest.param({"os_dict": WINDOWS_LATEST})],
+    indirect=True,
+)
+class TestVideoConfigWindows:
+    """Test VideoConfig with Windows VMs."""
+
+    @pytest.mark.polarion("CNV-11311")
+    @pytest.mark.high_resource_vm
+    @pytest.mark.parametrize(
+        "video_config_vm, expected_video_type",
+        [
+            pytest.param(
+                {
+                    "vm_name": "windows-vm-video-vga",
+                    "template_labels": WINDOWS_LATEST_LABELS,
+                    "vm_dict": create_vm_spec_with_video_type(VIDEO_TYPE_VGA),
+                },
+                VIDEO_TYPE_VGA,
+                id="test_windows_vm_vga_video",
+            ),
+        ],
+        indirect=["video_config_vm"],
+    )
+    def test_windows_vm_with_vga_video_type(self, video_config_vm, expected_video_type):
+        """
+        Test Windows VM creation with VGA video device type.
+
+        Polarion:
+            assignee: agupta
+            casecomponent: virt
+            caseimportance: high
+            initialEstimate: 1/2h
+            testSteps:
+                1. Create Windows VM with video.type=vga
+                2. Start VM
+                3. Verify domain XML has vga video model
+            expectedResults:
+                1. VM created successfully
+                2. VM started successfully
+                3. Domain XML shows model type="vga"
+        """
+        actual_video_type = get_video_model_from_domain_xml(vm=video_config_vm)
+        assert actual_video_type == expected_video_type, (
+            f"Video type mismatch for Windows VM. Expected: {expected_video_type}, Actual: {actual_video_type}"
+        )
+
+
+@pytest.mark.parametrize(
+    "golden_image_data_source_for_test_scope_class",
+    [pytest.param({"os_dict": RHEL_LATEST})],
+    indirect=True,
+)
+class TestVideoConfigNegative:
+    """Negative tests for VideoConfig feature."""
+
+    @pytest.mark.polarion("CNV-11312")
+    def test_invalid_video_type_rejected(
+        self,
+        unprivileged_client,
+        namespace,
+    ):
+        """
+        Test that invalid video device type is rejected with clear error.
+
+        Polarion:
+            assignee: agupta
+            casecomponent: virt
+            caseimportance: high
+            initialEstimate: 1/4h
+            testSteps:
+                1. Attempt to create VM with invalid video.type value
+                2. Verify API rejects the request
+                3. Verify error message is clear and informative
+            expectedResults:
+                1. VM creation attempted
+                2. API request rejected
+                3. Clear validation error returned
+        """
+        invalid_vm_body = {
+            "apiVersion": "kubevirt.io/v1",
+            "kind": "VirtualMachine",
+            "metadata": {
+                "name": "test-vm-invalid-video",
+                "namespace": namespace.name,
+            },
+            "spec": {
+                "running": False,
+                "template": {
+                    "spec": {
+                        "domain": {
+                            "devices": {
+                                "video": {
+                                    "type": "invalid_video_type",
+                                },
+                                "disks": [
+                                    {
+                                        "name": "containerdisk",
+                                        "disk": {"bus": "virtio"},
+                                    }
+                                ],
+                            },
+                            "resources": {
+                                "requests": {
+                                    "memory": "1Gi",
+                                }
+                            },
+                        },
+                        "volumes": [
+                            {
+                                "name": "containerdisk",
+                                "containerDisk": {
+                                    "image": "quay.io/kubevirt/fedora-cloud-container-disk-demo:latest"
+                                },
+                            }
+                        ],
+                    }
+                },
+            },
+        }
+
+        # Attempt to create VM with invalid video type
+        with pytest.raises(Exception) as exc_info:
+            VirtualMachine(
+                client=unprivileged_client,
+                namespace=namespace.name,
+                name="test-vm-invalid-video",
+                body=invalid_vm_body,
+            )
+
+        # Verify error message contains relevant information about the validation failure
+        error_message = str(exc_info.value).lower()
+        assert any(
+            keyword in error_message
+            for keyword in ["invalid", "video", "type", "validation", "supported"]
+        ), f"Error message doesn't clearly indicate video type validation failure: {exc_info.value}"
+
+    @pytest.mark.polarion("CNV-11313")
+    def test_vm_creation_with_feature_gate_disabled(
+        self,
+        hyperconverged_resource_scope_function,
+        unprivileged_client,
+        namespace,
+    ):
+        """
+        Test VM creation behavior when VideoConfig feature gate is disabled.
+
+        Polarion:
+            assignee: agupta
+            casecomponent: virt
+            caseimportance: high
+            initialEstimate: 1/4h
+            testSteps:
+                1. Disable VideoConfig feature gate in HCO
+                2. Attempt to create VM with video.type field
+                3. Verify VM either ignores the field or uses default video configuration
+            expectedResults:
+                1. Feature gate disabled successfully
+                2. VM creation attempted
+                3. VM uses default video configuration (backward compatibility)
+        """
+        with ResourceEditorValidateHCOReconcile(
+            patches={
+                hyperconverged_resource_scope_function: {
+                    "spec": {FEATURE_GATES: {VIDEO_CONFIG_FG: not FG_ENABLED}}
+                }
+            },
+            list_resource_reconcile=[KubeVirt],
+            wait_for_reconcile_post_update=True,
+        ):
+            # Create VM with video.type while FG is disabled
+            vm_body = {
+                "apiVersion": "kubevirt.io/v1",
+                "kind": "VirtualMachine",
+                "metadata": {
+                    "name": "test-vm-fg-disabled",
+                    "namespace": namespace.name,
+                },
+                "spec": {
+                    "running": False,
+                    "template": {
+                        "spec": {
+                            "domain": {
+                                "devices": {
+                                    "video": {
+                                        "type": VIDEO_TYPE_VIRTIO,
+                                    },
+                                    "disks": [
+                                        {
+                                            "name": "containerdisk",
+                                            "disk": {"bus": "virtio"},
+                                        }
+                                    ],
+                                },
+                                "resources": {
+                                    "requests": {
+                                        "memory": "1Gi",
+                                    }
+                                },
+                            },
+                            "volumes": [
+                                {
+                                    "name": "containerdisk",
+                                    "containerDisk": {
+                                        "image": "quay.io/kubevirt/fedora-cloud-container-disk-demo:latest"
+                                    },
+                                }
+                            ],
+                        }
+                    },
+                },
+            }
+
+            vm = VirtualMachine(
+                client=unprivileged_client,
+                namespace=namespace.name,
+                name="test-vm-fg-disabled",
+                body=vm_body,
+            )
+
+            try:
+                vm.deploy(wait=True)
+                # If VM created successfully, verify it uses default video config
+                # The video.type field should be ignored when FG is disabled
+                LOGGER.info(
+                    "VM created successfully with VideoConfig FG disabled. "
+                    "This indicates backward compatibility - video.type field is ignored."
+                )
+            except Exception as ex:
+                # If creation fails, it should fail with a clear validation error
+                LOGGER.info(f"VM creation failed with VideoConfig FG disabled: {ex}")
+                error_message = str(ex).lower()
+                assert any(
+                    keyword in error_message
+                    for keyword in ["video", "feature", "gate", "disabled", "not supported"]
+                ), f"Error message unclear when FG disabled: {ex}"
+            finally:
+                if vm.exists:
+                    vm.clean_up()
